MKSH(1)                   BSD General Commands Manual                  MKSH(1)

NNAAMMEE
     mmkksshh, sshh -- MirBSD Korn shell

SSYYNNOOPPSSIISS
     mmkksshh [--++aabbCCeeffhhiikkllmmnnpprrUUuuvvXXxx] [--TT [_!]_t_t_y | _-] [--++oo _o_p_t_i_o_n] [--cc _s_t_r_i_n_g | --ss
          | _f_i_l_e [_a_r_g_u_m_e_n_t _._._.]]
     bbuuiillttiinn--nnaammee [_a_r_g_u_m_e_n_t _._._.]

DDEESSCCRRIIPPTTIIOONN
     mmkksshh is a command interpreter intended for both interactive and shell
     script use.  Its command language is a superset of the sh(C) shell lan-
     guage and largely compatible to the original Korn shell.

   II''mm aann AAnnddrrooiidd uusseerr,, ssoo wwhhaatt''ss mmkksshh??
     mmkksshh is a UNIX shell / command interpreter, similar to CCOOMMMMAANNDD..CCOOMM or
     CCMMDD..EEXXEE, which has been included with Android Open Source Project for a
     while now.  Basically, it's a program that runs in a terminal (console
     window), takes user input and runs commands or scripts, which it can also
     be asked to do by other programs, even in the background.  Any privilege
     pop-ups you might be encountering are thus not mmkksshh issues but questions
     by some other program utilising it.

   IInnvvooccaattiioonn
     Most builtins can be called directly, for example if a link points from
     its name to the shell; not all make sense, have been tested or work at
     all though.

     The options are as follows:

     --cc _s_t_r_i_n_g  mmkksshh will execute the command(s) contained in _s_t_r_i_n_g.

     --ii         Interactive shell.  A shell that reads commands from standard
                input is "interactive" if this option is used or if both stan-
                dard input and standard error are attached to a tty(4).  An
                interactive shell has job control enabled, ignores the SIGINT,
                SIGQUIT, and SIGTERM signals, and prints prompts before read-
                ing input (see the PS1 and PS2 parameters).  It also processes
                the ENV parameter or the _m_k_s_h_r_c file (see below).  For non-
                interactive shells, the ttrraacckkaallll option is on by default (see
                the sseett command below).

     --ll         Login shell.  If the basename the shell is called with (i.e.
                argv[0]) starts with '-' or if this option is used, the shell
                is assumed to be a login shell; see _S_t_a_r_t_u_p _f_i_l_e_s below.

     --pp         Privileged shell.  A shell is "privileged" if the real user ID
                or group ID does not match the effective user ID or group ID
                (see getuid(2) and getgid(2)).  Clearing the privileged option
                causes the shell to set its effective user ID (group ID) to
                its real user ID (group ID).  For further implications, see
                _S_t_a_r_t_u_p _f_i_l_e_s.  If the shell is privileged and this flag is
                not explicitly set, the "privileged" option is cleared auto-
                matically after processing the startup files.

     --rr         Restricted shell.  A shell is "restricted" if this option is
                used.  The following restrictions come into effect after the
                shell processes any profile and ENV files:

                ++oo   The ccdd (and cchhddiirr) command is disabled.
                ++oo   The SHELL, ENV, and PATH parameters cannot be changed.
                ++oo   Command names can't be specified with absolute or relative
                    paths.
                ++oo   The --pp option of the built-in command ccoommmmaanndd can't be
                    used.
                ++oo   Redirections that create files can't be used (i.e. '>',
                    '>|', '>>', '<>').

     --ss         The shell reads commands from standard input; all non-option
                arguments are positional parameters.

     --TT _n_a_m_e    Spawn mmkksshh on the tty(4) device given.  The paths _n_a_m_e,
                _/_d_e_v_/_t_t_y_C_n_a_m_e and _/_d_e_v_/_t_t_y_n_a_m_e are attempted in order.  Unless
                _n_a_m_e begins with an exclamation mark ('!'), this is done in a
                subshell and returns immediately.  If _n_a_m_e is a dash ('-'),
                detach from controlling terminal (daemonise) instead.

     In addition to the above, the options described in the sseett built-in com-
     mand can also be used on the command line: both [--++aabbCCeeffhhkkmmnnuuvvXXxx] and
     [--++oo _o_p_t_i_o_n] can be used for single letter or long options, respectively.

     If neither the --cc nor the --ss option is specified, the first non-option
     argument specifies the name of a file the shell reads commands from.  If
     there are no non-option arguments, the shell reads commands from the
     standard input.  The name of the shell (i.e. the contents of $0) is
     determined as follows: if the --cc option is used and there is a non-option
     argument, it is used as the name; if commands are being read from a file,
     the file is used as the name; otherwise, the basename the shell was
     called with (i.e. argv[0]) is used.

     The exit status of the shell is 127 if the command file specified on the
     command line could not be opened, or non-zero if a fatal syntax error
     occurred during the execution of a script.  In the absence of fatal
     errors, the exit status is that of the last command executed, or zero, if
     no command is executed.

   SSttaarrttuupp ffiilleess
     For the actual location of these files, see _F_I_L_E_S.  A login shell pro-
     cesses the system profile first.  A privileged shell then processes the
     suid profile.  A non-privileged login shell processes the user profile
     next.  A non-privileged interactive shell checks the value of the ENV
     parameter after subjecting it to parameter, command, arithmetic and tilde
     ('~') substitution; if unset or empty, the user mkshrc profile is pro-
     cessed; otherwise, if a file whose name is the substitution result
     exists, it is processed; non-existence is silently ignored.  A privileged
     shell then drops privileges if neither was the --pp option given on the
     command line nor set during execution of the startup files.

   CCoommmmaanndd ssyynnttaaxx
     The shell begins parsing its input by removing any backslash-newline com-
     binations, then breaking it into _w_o_r_d_s.  Words (which are sequences of
     characters) are delimited by unquoted whitespace characters (space, tab,
     and newline) or meta-characters ('<', '>', '|', ';', '(', ')', and '&').
     Aside from delimiting words, spaces and tabs are ignored, while newlines
     usually delimit commands.  The meta-characters are used in building the
     following _t_o_k_e_n_s: '<', '<&', '<<', '<<<', '>', '>&', '>>', '&>', etc. are
     used to specify redirections (see _I_n_p_u_t_/_o_u_t_p_u_t _r_e_d_i_r_e_c_t_i_o_n below); '|' is
     used to create pipelines; '|&' is used to create co-processes (see
     _C_o_-_p_r_o_c_e_s_s_e_s below); ';' is used to separate commands; '&' is used to
     create asynchronous pipelines; '&&' and '||' are used to specify condi-
     tional execution; ';;', ';&' and ';|' are used in ccaassee statements; '(( ..
     ))' is used in arithmetic expressions; and lastly, '( .. )' is used to
     create subshells.

     Whitespace and meta-characters can be quoted individually using a back-
     slash ('\'), or in groups using double ('"') or single (''') quotes.
     Note that the following characters are also treated specially by the
     shell and must be quoted if they are to represent themselves: '\', '"',
     ''', '#', '$', '`', '~', '{', '}', '*', '?', and '['.  The first three of
     these are the above mentioned quoting characters (see _Q_u_o_t_i_n_g below);
     '#', if used at the beginning of a word, introduces a comment - every-
     thing after the '#' up to the nearest newline is ignored; '$' is used to
     introduce parameter, command, and arithmetic substitutions (see
     _S_u_b_s_t_i_t_u_t_i_o_n below); '`' introduces an old-style command substitution
     (see _S_u_b_s_t_i_t_u_t_i_o_n below); '~' begins a directory expansion (see _T_i_l_d_e
     _e_x_p_a_n_s_i_o_n below); '{' and '}' delimit csh(1)-style alternations (see
     _B_r_a_c_e _e_x_p_a_n_s_i_o_n below); and finally, '*', '?', and '[' are used in file
     name generation (see _F_i_l_e _n_a_m_e _p_a_t_t_e_r_n_s below).

     As words and tokens are parsed, the shell builds commands, of which there
     are two basic types: _s_i_m_p_l_e_-_c_o_m_m_a_n_d_s, typically programmes that are exe-
     cuted, and _c_o_m_p_o_u_n_d_-_c_o_m_m_a_n_d_s, such as ffoorr and iiff statements, grouping
     constructs, and function definitions.

     A simple-command consists of some combination of parameter assignments
     (see _P_a_r_a_m_e_t_e_r_s below), input/output redirections (see _I_n_p_u_t_/_o_u_t_p_u_t
     _r_e_d_i_r_e_c_t_i_o_n_s below), and command words; the only restriction is that
     parameter assignments come before any command words.  The command words,
     if any, define the command that is to be executed and its arguments.  The
     command may be a shell built-in command, a function, or an external com-
     mand (i.e. a separate executable file that is located using the PATH
     parameter; see _C_o_m_m_a_n_d _e_x_e_c_u_t_i_o_n below).  Note that all command con-
     structs have an exit status: for external commands, this is related to
     the status returned by wait(2) (if the command could not be found, the
     exit status is 127; if it could not be executed, the exit status is 126);
     the exit status of other command constructs (built-in commands, func-
     tions, compound-commands, pipelines, lists, etc.) are all well-defined
     and are described where the construct is described.  The exit status of a
     command consisting only of parameter assignments is that of the last com-
     mand substitution performed during the parameter assignment or 0 if there
     were no command substitutions.

     Commands can be chained together using the '|' token to form pipelines,
     in which the standard output of each command but the last is piped (see
     pipe(2)) to the standard input of the following command.  The exit status
     of a pipeline is that of its last command, unless the ppiippeeffaaiill option is
     set (see there).  All commands of a pipeline are executed in separate
     subshells; this is allowed by POSIX but differs from both variants of
     AT&T UNIX kksshh, where all but the last command were executed in subshells;
     see the rreeaadd builtin's description for implications and workarounds.  A
     pipeline may be prefixed by the '!' reserved word which causes the exit
     status of the pipeline to be logically complemented: if the original sta-
     tus was 0, the complemented status will be 1; if the original status was
     not 0, the complemented status will be 0.

     _L_i_s_t_s of commands can be created by separating pipelines by any of the
     following tokens: '&&', '||', '&', '|&', and ';'.  The first two are for
     conditional execution: "_c_m_d_1 && _c_m_d_2" executes _c_m_d_2 only if the exit sta-
     tus of _c_m_d_1 is zero; '||' is the opposite - _c_m_d_2 is executed only if the
     exit status of _c_m_d_1 is non-zero.  '&&' and '||' have equal precedence
     which is higher than that of '&', '|&', and ';', which also have equal
     precedence.  Note that the '&&' and '||' operators are
     "left-associative".  For example, both of these commands will print only
     "bar":

           $ false && echo foo || echo bar
           $ true || echo foo && echo bar

     The '&' token causes the preceding command to be executed asynchronously;
     that is, the shell starts the command but does not wait for it to com-
     plete (the shell does keep track of the status of asynchronous commands;
     see _J_o_b _c_o_n_t_r_o_l below).  When an asynchronous command is started when job
     control is disabled (i.e. in most scripts), the command is started with
     signals SIGINT and SIGQUIT ignored and with input redirected from
     _/_d_e_v_/_n_u_l_l (however, redirections specified in the asynchronous command
     have precedence).  The '|&' operator starts a co-process which is a spe-
     cial kind of asynchronous process (see _C_o_-_p_r_o_c_e_s_s_e_s below).  Note that a
     command must follow the '&&' and '||' operators, while it need not follow
     '&', '|&', or ';'.  The exit status of a list is that of the last command
     executed, with the exception of asynchronous lists, for which the exit
     status is 0.

     Compound commands are created using the following reserved words.  These
     words are only recognised if they are unquoted and if they are used as
     the first word of a command (i.e. they can't be preceded by parameter
     assignments or redirections):

           case     else     function     then      !       (
           do       esac     if           time      [[      ((
           done     fi       in           until     {
           elif     for      select       while     }

     In the following compound command descriptions, command lists (denoted as
     _l_i_s_t) that are followed by reserved words must end with a semicolon, a
     newline, or a (syntactically correct) reserved word.  For example, the
     following are all valid:

           $ { echo foo; echo bar; }
           $ { echo foo; echo bar<newline>}
           $ { { echo foo; echo bar; } }

     This is not valid:

           $ { echo foo; echo bar }

     (_l_i_s_t)
           Execute _l_i_s_t in a subshell.  There is no implicit way to pass envi-
           ronment changes from a subshell back to its parent.

     { _l_i_s_t; }
           Compound construct; _l_i_s_t is executed, but not in a subshell.  Note
           that '{' and '}' are reserved words, not meta-characters.

     case _w_o_r_d in [[(] _p_a_t_t_e_r_n [| _p_a_t_t_e_r_n] ...) _l_i_s_t tteerrmmiinnaattoorr] ... esac
           The ccaassee statement attempts to match _w_o_r_d against a specified
           _p_a_t_t_e_r_n; the _l_i_s_t associated with the first successfully matched
           pattern is executed.  Patterns used in ccaassee statements are the same
           as those used for file name patterns except that the restrictions
           regarding '.' and '/' are dropped.  Note that any unquoted space
           before and after a pattern is stripped; any space within a pattern
           must be quoted.  Both the word and the patterns are subject to
           parameter, command, and arithmetic substitution, as well as tilde
           substitution.

           For historical reasons, open and close braces may be used instead
           of iinn and eessaacc e.g. ccaassee $$ffoooo {{ **)) eecchhoo bbaarr ;;;; }}.

           The list tteerrmmiinnaattoorrs are:

           ';;'  Terminate after the list.

           ';&'  Fall through into the next list.

           ';|'  Evaluate the remaining pattern-list tuples.

           The exit status of a ccaassee statement is that of the executed _l_i_s_t;
           if no _l_i_s_t is executed, the exit status is zero.

     for _n_a_m_e [in _w_o_r_d ...]; do _l_i_s_t; done
           For each _w_o_r_d in the specified word list, the parameter _n_a_m_e is set
           to the word and _l_i_s_t is executed.  If iinn is not used to specify a
           word list, the positional parameters ($1, $2, etc.) are used
           instead.  For historical reasons, open and close braces may be used
           instead of ddoo and ddoonnee e.g. ffoorr ii;; {{ eecchhoo $$ii;; }}.  The exit status
           of a ffoorr statement is the last exit status of _l_i_s_t; if _l_i_s_t is
           never executed, the exit status is zero.

     if _l_i_s_t; then _l_i_s_t; [elif _l_i_s_t; then _l_i_s_t;] ... [else _l_i_s_t;] fi
           If the exit status of the first _l_i_s_t is zero, the second _l_i_s_t is
           executed; otherwise, the _l_i_s_t following the eelliiff, if any, is exe-
           cuted with similar consequences.  If all the lists following the iiff
           and eelliiffs fail (i.e. exit with non-zero status), the _l_i_s_t following
           the eellssee is executed.  The exit status of an iiff statement is that
           of non-conditional _l_i_s_t that is executed; if no non-conditional
           _l_i_s_t is executed, the exit status is zero.

     select _n_a_m_e [in _w_o_r_d ...]; do _l_i_s_t; done
           The sseelleecctt statement provides an automatic method of presenting the
           user with a menu and selecting from it.  An enumerated list of the
           specified _w_o_r_d(s) is printed on standard error, followed by a
           prompt (PS3: normally '#? ').  A number corresponding to one of the
           enumerated words is then read from standard input, _n_a_m_e is set to
           the selected word (or unset if the selection is not valid), REPLY
           is set to what was read (leading/trailing space is stripped), and
           _l_i_s_t is executed.  If a blank line (i.e. zero or more IFS octets)
           is entered, the menu is reprinted without executing _l_i_s_t.

           When _l_i_s_t completes, the enumerated list is printed if REPLY is
           NULL, the prompt is printed, and so on.  This process continues
           until an end-of-file is read, an interrupt is received, or a bbrreeaakk
           statement is executed inside the loop.  If "in word ..." is omit-
           ted, the positional parameters are used (i.e. $1, $2, etc.).  For
           historical reasons, open and close braces may be used instead of ddoo
           and ddoonnee e.g. sseelleecctt ii;; {{ eecchhoo $$ii;; }}.  The exit status of a sseelleecctt
           statement is zero if a bbrreeaakk statement is used to exit the loop,
           non-zero otherwise.

     until _l_i_s_t; do _l_i_s_t; done
           This works like wwhhiillee, except that the body is executed only while
           the exit status of the first _l_i_s_t is non-zero.

     while _l_i_s_t; do _l_i_s_t; done
           A wwhhiillee is a pre-checked loop.  Its body is executed as often as
           the exit status of the first _l_i_s_t is zero.  The exit status of a
           wwhhiillee statement is the last exit status of the _l_i_s_t in the body of
           the loop; if the body is not executed, the exit status is zero.

     function _n_a_m_e { _l_i_s_t; }
           Defines the function _n_a_m_e (see _F_u_n_c_t_i_o_n_s below).  Note that redi-
           rections specified after a function definition are performed when-
           ever the function is executed, not when the function definition is
           executed.

     _n_a_m_e() _c_o_m_m_a_n_d
           Mostly the same as ffuunnccttiioonn (see _F_u_n_c_t_i_o_n_s below).  Whitespace
           (space or tab) after _n_a_m_e will be ignored most of the time.

     function _n_a_m_e() { _l_i_s_t; }
           The same as _n_a_m_e() (bbaasshhism).  The ffuunnccttiioonn keyword is ignored.

     ttiimmee [--pp] [_p_i_p_e_l_i_n_e]
           The _C_o_m_m_a_n_d _e_x_e_c_u_t_i_o_n section describes the ttiimmee reserved word.

     (( _e_x_p_r_e_s_s_i_o_n ))
           The arithmetic expression _e_x_p_r_e_s_s_i_o_n is evaluated; equivalent to
           "let expression" (see _A_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n_s and the lleett command,
           below).

     [[ _e_x_p_r_e_s_s_i_o_n ]]
           Similar to the tteesstt and [[ ...... ]] commands (described later), with
           the following exceptions:

           ++oo   Field splitting and file name generation are not performed on
               arguments.

           ++oo   The --aa (AND) and --oo (OR) operators are replaced with '&&' and
               '||', respectively.

           ++oo   Operators (e.g. '--ff', '=', '!') must be unquoted.

           ++oo   Parameter, command, and arithmetic substitutions are performed
               as expressions are evaluated and lazy expression evaluation is
               used for the '&&' and '||' operators.  This means that in the
               following statement, $$((<<ffoooo)) is evaluated if and only if the
               file _f_o_o exists and is readable:

                     $ [[ -r foo && $(<foo) = b*r ]]

           ++oo   The second operand of the '!=' and '=' expressions are a subset
               of patterns (e.g. the comparison [[[[ ffoooobbaarr == ff**rr ]]]] succeeds).
               This even works indirectly:

                     $ bar=foobar; baz='f*r'
                     $ [[ $bar = $baz ]]; echo $?
                     $ [[ $bar = "$baz" ]]; echo $?

               Perhaps surprisingly, the first comparison succeeds, whereas
               the second doesn't.  This does not apply to all extglob
               metacharacters, currently.

   QQuuoottiinngg
     Quoting is used to prevent the shell from treating characters or words
     specially.  There are three methods of quoting.  First, '\' quotes the
     following character, unless it is at the end of a line, in which case
     both the '\' and the newline are stripped.  Second, a single quote (''')
     quotes everything up to the next single quote (this may span lines).
     Third, a double quote ('"') quotes all characters, except '$', '`' and
     '\', up to the next unquoted double quote.  '$' and '`' inside double
     quotes have their usual meaning (i.e. parameter, command, or arithmetic
     substitution) except no field splitting is carried out on the results of
     double-quoted substitutions.  If a '\' inside a double-quoted string is
     followed by '\', '$', '`', or '"', it is replaced by the second charac-
     ter; if it is followed by a newline, both the '\' and the newline are
     stripped; otherwise, both the '\' and the character following are
     unchanged.

     If a single-quoted string is preceded by an unquoted '$', C style back-
     slash expansion (see below) is applied (even single quote characters
     inside can be escaped and do not terminate the string then); the expanded
     result is treated as any other single-quoted string.  If a double-quoted
     string is preceded by an unquoted '$', the latter is ignored.

   BBaacckkssllaasshh eexxppaannssiioonn
     In places where backslashes are expanded, certain C and AT&T UNIX kksshh or
     GNU bbaasshh style escapes are translated.  These include '\a', '\b', '\f',
     '\n', '\r', '\t', '\U########', '\u####', and '\v'.  For '\U########' and
     '\u####', "#" means a hexadecimal digit, of thich there may be none up to
     four or eight; these escapes translate a Unicode codepoint to UTF-8.
     Furthermore, '\E' and '\e' expand to the escape character.

     In the pprriinntt builtin mode, '\"', '\'', and '\?' are explicitly excluded;
     octal sequences must have the none up to three octal digits "#" prefixed
     with the digit zero ('\0###'); hexadecimal sequences '\x##' are limited
     to none up to two hexadecimal digits "#"; both octal and hexadecimal
     sequences convert to raw octets; '\#', where # is none of the above,
     translates to \# (backslashes are retained).

     Backslash expansion in the C style mode slightly differs: octal sequences
     '\###' must have no digit zero prefixing the one up to three octal digits
     "#" and yield raw octets; hexadecimal sequences '\x#*' greedily eat up as
     many hexadecimal digits "#" as they can and terminate with the first non-
     hexadecimal digit; these translate a Unicode codepoint to UTF-8.  The
     sequence '\c#', where "#" is any octet, translates to Ctrl-# (which basi-
     cally means, '\c?' becomes DEL, everything else is bitwise ANDed with
     0x1F).  Finally, '\#', where # is none of the above, translates to # (has
     the backslash trimmed), even if it is a newline.

   AAlliiaasseess
     There are two types of aliases: normal command aliases and tracked
     aliases.  Command aliases are normally used as a short hand for a long or
     often used command.  The shell expands command aliases (i.e. substitutes
     the alias name for its value) when it reads the first word of a command.
     An expanded alias is re-processed to check for more aliases.  If a com-
     mand alias ends in a space or tab, the following word is also checked for
     alias expansion.  The alias expansion process stops when a word that is
     not an alias is found, when a quoted word is found, or when an alias word
     that is currently being expanded is found.  Aliases are specifically an
     interactive feature: while they do happen to work in scripts and on the
     command line in some cases, aliases are expanded during lexing, so their
     use must be in a separate command tree from their definition; otherwise,
     the alias will not be found.  Noticeably, command lists (separated by
     semicolon, in command substitutions also by newline) may be one same
     parse tree.

     The following command aliases are defined automatically by the shell:

           autoload='\typeset -fu'
           functions='\typeset -f'
           hash='\builtin alias -t'
           history='\builtin fc -l'
           integer='\typeset -i'
           local='\typeset'
           login='\exec login'
           nameref='\typeset -n'
           nohup='nohup '
           r='\builtin fc -e -'
           source='PATH=$PATH:. \command .'
           stop='\kill -STOP'
           type='\builtin whence -v'

     Tracked aliases allow the shell to remember where it found a particular
     command.  The first time the shell does a path search for a command that
     is marked as a tracked alias, it saves the full path of the command.  The
     next time the command is executed, the shell checks the saved path to see
     that it is still valid, and if so, avoids repeating the path search.
     Tracked aliases can be listed and created using aalliiaass --tt.  Note that
     changing the PATH parameter clears the saved paths for all tracked
     aliases.  If the ttrraacckkaallll option is set (i.e. sseett --oo ttrraacckkaallll or sseett --hh),
     the shell tracks all commands.  This option is set automatically for non-
     interactive shells.  For interactive shells, only the following commands
     are automatically tracked: cat(1), cc(1), chmod(1), cp(1), date(1),
     ed(1), emacs(1), grep(1), ls(1), make(1), mv(1), pr(1), rm(1), sed(1),
     sh(1), vi(1), and who(1).

   SSuubbssttiittuuttiioonn
     The first step the shell takes in executing a simple-command is to per-
     form substitutions on the words of the command.  There are three kinds of
     substitution: parameter, command, and arithmetic.  Parameter substitu-
     tions, which are described in detail in the next section, take the form
     $_n_a_m_e or ${_._._.}; command substitutions take the form $(_c_o_m_m_a_n_d) or (dep-
     recated) `_c_o_m_m_a_n_d` or (executed in the current environment) ${ _c_o_m_m_a_n_d;}
     and strip trailing newlines; and arithmetic substitutions take the form
     $((_e_x_p_r_e_s_s_i_o_n)).  Parsing the current-environment command substitution
     requires a space, tab or newline after the opening brace and that the
     closing brace be recognised as a keyword (i.e. is preceded by a newline
     or semicolon).  They are also called funsubs (function substitutions) and
     behave like functions in that llooccaall and rreettuurrnn work, and in that eexxiitt
     terminates the parent shell; shell options are shared.

     Another variant of substitution are the valsubs (value substitutions)
     ${|_c_o_m_m_a_n_d;} which are also executed in the current environment, like
     funsubs, but share their I/O with the parent; instead, they evaluate to
     whatever the, initially empty, expression-local variable REPLY is set to
     within the _c_o_m_m_a_n_ds.

     If a substitution appears outside of double quotes, the results of the
     substitution are generally subject to word or field splitting according
     to the current value of the IFS parameter.  The IFS parameter specifies a
     list of octets which are used to break a string up into several words;
     any octets from the set space, tab, and newline that appear in the IFS
     octets are called "IFS whitespace".  Sequences of one or more IFS white-
     space octets, in combination with zero or one non-IFS whitespace octets,
     delimit a field.  As a special case, leading and trailing IFS whitespace
     is stripped (i.e. no leading or trailing empty field is created by it);
     leading or trailing non-IFS whitespace does create an empty field.

     Example: If IFS is set to "<space>:", and VAR is set to
     "<space>A<space>:<space><space>B::D", the substitution for $VAR results
     in four fields: 'A', 'B', '' (an empty field), and 'D'.  Note that if the
     IFS parameter is set to the empty string, no field splitting is done; if
     it is unset, the default value of space, tab, and newline is used.

     Also, note that the field splitting applies only to the immediate result
     of the substitution.  Using the previous example, the substitution for
     $VAR:E results in the fields: 'A', 'B', '', and 'D:E', not 'A', 'B', '',
     'D', and 'E'.  This behavior is POSIX compliant, but incompatible with
     some other shell implementations which do field splitting on the word
     which contained the substitution or use IFS as a general whitespace
     delimiter.

     The results of substitution are, unless otherwise specified, also subject
     to brace expansion and file name expansion (see the relevant sections
     below).

     A command substitution is replaced by the output generated by the speci-
     fied command which is run in a subshell.  For $(_c_o_m_m_a_n_d) and ${ _c_o_m_m_a_n_d;}
     substitutions, normal quoting rules are used when _c_o_m_m_a_n_d is parsed; how-
     ever, for the deprecated `_c_o_m_m_a_n_d` form, a '\' followed by any of '$',
     '`', or '\' is stripped (a '\' followed by any other character is
     unchanged).  As a special case in command substitutions, a command of the
     form <_f_i_l_e is interpreted to mean substitute the contents of _f_i_l_e.  Note
     that $$((<<ffoooo)) has the same effect as $$((ccaatt ffoooo)).

     Note that some shells do not use a recursive parser for command substitu-
     tions, leading to failure for certain constructs; to be portable, use as
     workaround 'x=$(cat) <<"EOF"' (or the newline-keeping 'x=<<"EOF"' exten-
     sion) instead to merely slurp the string.  IEEE Std 1003.1 ("POSIX.1")
     recommends to use case statements of the form 'x=$(case $foo in (bar)
     echo $bar ;; (*) echo $baz ;; esac)' instead, which would work but not
     serve as example for this portability issue.

           x=$(case $foo in bar) echo $bar ;; *) echo $baz ;; esac)
           # above fails to parse on old shells; below is the workaround
           x=$(eval $(cat)) <<"EOF"
           case $foo in bar) echo $bar ;; *) echo $baz ;; esac
           EOF

     Arithmetic substitutions are replaced by the value of the specified
     expression.  For example, the command pprriinntt $$((((22++33**44)))) displays 14.  See
     _A_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n_s for a description of an expression.

   PPaarraammeetteerrss
     Parameters are shell variables; they can be assigned values and their
     values can be accessed using a parameter substitution.  A parameter name
     is either one of the special single punctuation or digit character param-
     eters described below, or a letter followed by zero or more letters or
     digits ('_' counts as a letter).  The latter form can be treated as
     arrays by appending an array index of the form [_e_x_p_r] where _e_x_p_r is an
     arithmetic expression.  Array indices in mmkksshh are limited to the range 0
     through 4294967295, inclusive.  That is, they are a 32-bit unsigned inte-
     ger.

     Parameter substitutions take the form $_n_a_m_e, ${_n_a_m_e}, or ${_n_a_m_e[_e_x_p_r]}
     where _n_a_m_e is a parameter name.  Substitution of all array elements with
     ${_n_a_m_e[*]} and ${_n_a_m_e[@]} works equivalent to $* and $@ for positional
     parameters.  If substitution is performed on a parameter (or an array
     parameter element) that is not set, a null string is substituted unless
     the nnoouunnsseett option (sseett --oo nnoouunnsseett or sseett --uu) is set, in which case an
     error occurs.

     Parameters can be assigned values in a number of ways.  First, the shell
     implicitly sets some parameters like '#', 'PWD', and '$'; this is the
     only way the special single character parameters are set.  Second, param-
     eters are imported from the shell's environment at startup.  Third,
     parameters can be assigned values on the command line: for example,
     FFOOOO==bbaarr sets the parameter "FOO" to "bar"; multiple parameter assignments
     can be given on a single command line and they can be followed by a sim-
     ple-command, in which case the assignments are in effect only for the
     duration of the command (such assignments are also exported; see below
     for the implications of this).  Note that both the parameter name and the
     '=' must be unquoted for the shell to recognise a parameter assignment.
     The construct FFOOOO++==bbaazz is also recognised; the old and new values are
     immediately concatenated.  The fourth way of setting a parameter is with
     the eexxppoorrtt, gglloobbaall, rreeaaddoonnllyy, and ttyyppeesseett commands; see their descrip-
     tions in the _C_o_m_m_a_n_d _e_x_e_c_u_t_i_o_n section.  Fifth, ffoorr and sseelleecctt loops set
     parameters as well as the ggeettooppttss, rreeaadd, and sseett --AA commands.  Lastly,
     parameters can be assigned values using assignment operators inside
     arithmetic expressions (see _A_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n_s below) or using the
     ${_n_a_m_e=_v_a_l_u_e} form of the parameter substitution (see below).

     Parameters with the export attribute (set using the eexxppoorrtt or ttyyppeesseett --xx
     commands, or by parameter assignments followed by simple commands) are
     put in the environment (see environ(7)) of commands run by the shell as
     _n_a_m_e=_v_a_l_u_e pairs.  The order in which parameters appear in the environ-
     ment of a command is unspecified.  When the shell starts up, it extracts
     parameters and their values from its environment and automatically sets
     the export attribute for those parameters.

     Modifiers can be applied to the ${_n_a_m_e} form of parameter substitution:

     ${_n_a_m_e:-_w_o_r_d}
             If _n_a_m_e is set and not NULL, it is substituted; otherwise, _w_o_r_d
             is substituted.

     ${_n_a_m_e:+_w_o_r_d}
             If _n_a_m_e is set and not NULL, _w_o_r_d is substituted; otherwise,
             nothing is substituted.

     ${_n_a_m_e:=_w_o_r_d}
             If _n_a_m_e is set and not NULL, it is substituted; otherwise, it is
             assigned _w_o_r_d and the resulting value of _n_a_m_e is substituted.

     ${_n_a_m_e:?_w_o_r_d}
             If _n_a_m_e is set and not NULL, it is substituted; otherwise, _w_o_r_d
             is printed on standard error (preceded by _n_a_m_e:) and an error
             occurs (normally causing termination of a shell script, function,
             or script sourced using the '.' built-in).  If _w_o_r_d is omitted,
             the string "parameter null or not set" is used instead.  Cur-
             rently a bug, if _w_o_r_d is a variable which expands to the null
             string, the error message is also printed.

     Note that, for all of the above, _w_o_r_d is actually considered quoted, and
     special parsing rules apply.  The parsing rules also differ on whether
     the expression is double-quoted: _w_o_r_d then uses double-quoting rules,
     except for the double quote itself ('"') and the closing brace, which, if
     backslash escaped, gets quote removal applied.

     In the above modifiers, the ':' can be omitted, in which case the condi-
     tions only depend on _n_a_m_e being set (as opposed to set and not NULL).  If
     _w_o_r_d is needed, parameter, command, arithmetic, and tilde substitution
     are performed on it; if _w_o_r_d is not needed, it is not evaluated.

     The following forms of parameter substitution can also be used (if _n_a_m_e
     is an array, the element with the key "0" will be substituted in scalar
     context):

     ${#_n_a_m_e}
             The number of positional parameters if _n_a_m_e is '*', '@', or not
             specified; otherwise the length (in characters) of the string
             value of parameter _n_a_m_e.

     ${#_n_a_m_e[*]}
     ${#_n_a_m_e[@]}
             The number of elements in the array _n_a_m_e.

     ${%_n_a_m_e}
             The width (in screen columns) of the string value of parameter
             _n_a_m_e, or -1 if ${_n_a_m_e} contains a control character.

     ${!_n_a_m_e}
             The name of the variable referred to by _n_a_m_e.  This will be _n_a_m_e
             except when _n_a_m_e is a name reference (bound variable), created by
             the nnaammeerreeff command (which is an alias for ttyyppeesseett --nn).

     ${!_n_a_m_e[*]}
     ${!_n_a_m_e[@]}
             The names of indices (keys) in the array _n_a_m_e.

     ${_n_a_m_e#_p_a_t_t_e_r_n}
     ${_n_a_m_e##_p_a_t_t_e_r_n}
             If _p_a_t_t_e_r_n matches the beginning of the value of parameter _n_a_m_e,
             the matched text is deleted from the result of substitution.  A
             single '#' results in the shortest match, and two of them result
             in the longest match.  Cannot be applied to a vector (${*} or
             ${@} or ${array[*]} or ${array[@]}).

     ${_n_a_m_e%_p_a_t_t_e_r_n}
     ${_n_a_m_e%%_p_a_t_t_e_r_n}
             Like ${..#..} substitution, but it deletes from the end of the
             value.  Cannot be applied to a vector.

     ${_n_a_m_e/_p_a_t_t_e_r_n_/_s_t_r_i_n_g}
     ${_n_a_m_e//_p_a_t_t_e_r_n_/_s_t_r_i_n_g}
             Similar to ${..##..} substitution, but it replaces the longest
             match of _p_a_t_t_e_r_n, anchored anywhere in the value, with _s_t_r_i_n_g.
             If _p_a_t_t_e_r_n begins with '#', it is anchored at the beginning of
             the value; if it begins with '%', it is anchored at the end.
             Empty patterns cause no replacement to happen.  A single leading
             '/' or use of a pattern that matches the empty string causes the
             replacement to happen only once; two leading slashes cause all
             occurrences of matches in the value to be replaced.  If the
             trailing /_s_t_r_i_n_g is omitted, any matches of _p_a_t_t_e_r_n are replaced
             by the empty string, i.e. deleted.  Cannot be applied to a vec-
             tor.  Inefficiently implemented, may be slow.

     ${_n_a_m_e:_p_o_s:_l_e_n}
             The first _l_e_n characters of _n_a_m_e, starting at position _p_o_s, are
             substituted.  Both _p_o_s and :_l_e_n are optional.  If _p_o_s is nega-
             tive, counting starts at the end of the string; if it is omitted,
             it defaults to 0.  If _l_e_n is omitted or greater than the length
             of the remaining string, all of it is substituted.  Both _p_o_s and
             _l_e_n are evaluated as arithmetic expressions.  Currently, _p_o_s must
             start with a space, opening parenthesis or digit to be recog-
             nised.  Cannot be applied to a vector.

     ${_n_a_m_e@#}
             The hash (using the BAFH algorithm) of the expansion of _n_a_m_e.
             This is also used internally for the shell's hashtables.

     ${_n_a_m_e@Q}
             A quoted expression safe for re-entry, whose value is the value
             of the _n_a_m_e parameter, is substituted.

     Note that _p_a_t_t_e_r_n may need extended globbing pattern (@(...)), single
     ('...') or double ("...") quote escaping unless --oo sshh is set.

     The following special parameters are implicitly set by the shell and can-
     not be set directly using assignments:

     !       Process ID of the last background process started.  If no back-
             ground processes have been started, the parameter is not set.

     #       The number of positional parameters ($1, $2, etc.).

     $       The PID of the shell, or the PID of the original shell if it is a
             subshell.  Do _N_O_T use this mechanism for generating temporary
             file names; see mktemp(1) instead.

     -       The concatenation of the current single letter options (see the
             sseett command below for a list of options).

     ?       The exit status of the last non-asynchronous command executed.
             If the last command was killed by a signal, $$?? is set to 128 plus
             the signal number.

     0       The name of the shell, determined as follows: the first argument
             to mmkksshh if it was invoked with the --cc option and arguments were
             given; otherwise the _f_i_l_e argument, if it was supplied; or else
             the basename the shell was invoked with (i.e. argv[0]).  $0 is
             also set to the name of the current script or the name of the
             current function, if it was defined with the ffuunnccttiioonn keyword
             (i.e. a Korn shell style function).

     1 .. 9  The first nine positional parameters that were supplied to the
             shell, function, or script sourced using the '.' built-in.  Fur-
             ther positional parameters may be accessed using ${_n_u_m_b_e_r}.

     *       All positional parameters (except 0), i.e. $1, $2, $3, ...
             If used outside of double quotes, parameters are separate words
             (which are subjected to word splitting); if used within double
             quotes, parameters are separated by the first character of the
             IFS parameter (or the empty string if IFS is NULL).

     @       Same as $$**, unless it is used inside double quotes, in which case
             a separate word is generated for each positional parameter.  If
             there are no positional parameters, no word is generated.  $$@@ can
             be used to access arguments, verbatim, without losing NULL argu-
             ments or splitting arguments with spaces.

     The following parameters are set and/or used by the shell:

     _            (underscore) When an external command is executed by the
                  shell, this parameter is set in the environment of the new
                  process to the path of the executed command.  In interactive
                  use, this parameter is also set in the parent shell to the
                  last word of the previous command.

     BASHPID      The PID of the shell or subshell.

     CDPATH       Like PATH, but used to resolve the argument to the ccdd built-
                  in command.  Note that if CDPATH is set and does not contain
                  '.' or an empty string element, the current directory is not
                  searched.  Also, the ccdd built-in command will display the
                  resulting directory when a match is found in any search path
                  other than the empty path.

     COLUMNS      Set to the number of columns on the terminal or window.
                  Always set, defaults to 80, unless the value as reported by
                  stty(1) is non-zero and sane enough (minimum is 12x3); simi-
                  lar for LINES.  This parameter is used by the interactive
                  line editing modes, and by the sseelleecctt, sseett --oo, and kkiillll --ll
                  commands to format information columns.  Importing from the
                  environment or unsetting this parameter removes the binding
                  to the actual terminal size in favour of the provided value.

     ENV          If this parameter is found to be set after any profile files
                  are executed, the expanded value is used as a shell startup
                  file.  It typically contains function and alias definitions.

     ERRNO        Integer value of the shell's _e_r_r_n_o variable.  It indicates
                  the reason the last system call failed.  Not yet imple-
                  mented.

     EXECSHELL    If set, this parameter is assumed to contain the shell that
                  is to be used to execute commands that execve(2) fails to
                  execute and which do not start with a "#!_s_h_e_l_l" sequence.

     FCEDIT       The editor used by the ffcc command (see below).

     FPATH        Like PATH, but used when an undefined function is executed
                  to locate the file defining the function.  It is also
                  searched when a command can't be found using PATH.  See
                  _F_u_n_c_t_i_o_n_s below for more information.

     HISTFILE     The name of the file used to store command history.  When
                  assigned to or unset, the file is opened, history is trun-
                  cated then loaded from the file; subsequent new commands
                  (possibly consisting of several lines) are appended once
                  they successfully compiled.  Also, several invocations of
                  the shell will share history if their HISTFILE parameters
                  all point to the same file.

                  NNoottee: If HISTFILE is unset or empty, no history file is
                  used.  This is different from AT&T UNIX kksshh.

     HISTSIZE     The number of commands normally stored for history.  The
                  default is 2047.  Do not set this value to insanely high
                  values such as 1000000000 because mmkksshh can then not allocate
                  enough memory for the history and will not start.

     HOME         The default directory for the ccdd command and the value sub-
                  stituted for an unqualified ~~ (see _T_i_l_d_e _e_x_p_a_n_s_i_o_n below).

     IFS          Internal field separator, used during substitution and by
                  the rreeaadd command, to split values into distinct arguments;
                  normally set to space, tab, and newline.  See _S_u_b_s_t_i_t_u_t_i_o_n
                  above for details.

                  NNoottee: This parameter is not imported from the environment
                  when the shell is started.

     KSHEGID      The effective group id of the shell.

     KSHGID       The real group id of the shell.

     KSHUID       The real user id of the shell.

     KSH_VERSION  The name and version of the shell (read-only).  See also the
                  version commands in _E_m_a_c_s _e_d_i_t_i_n_g _m_o_d_e and _V_i _e_d_i_t_i_n_g _m_o_d_e
                  sections, below.

     LINENO       The line number of the function or shell script that is cur-
                  rently being executed.

     LINES        Set to the number of lines on the terminal or window.
                  Always set, defaults to 24.  See COLUMNS.

     EPOCHREALTIME
                  Time since the epoch, as returned by gettimeofday(2), for-
                  matted as decimal _t_v___s_e_c followed by a dot ('.') and _t_v___u_s_e_c
                  padded to exactly six decimal digits.

     OLDPWD       The previous working directory.  Unset if ccdd has not suc-
                  cessfully changed directories since the shell started, or if
                  the shell doesn't know where it is.

     OPTARG       When using ggeettooppttss, it contains the argument for a parsed
                  option, if it requires one.

     OPTIND       The index of the next argument to be processed when using
                  ggeettooppttss.  Assigning 1 to this parameter causes ggeettooppttss to
                  process arguments from the beginning the next time it is
                  invoked.

     PATH         A colon separated list of directories that are searched when
                  looking for commands and files sourced using the '.' command
                  (see below).  An empty string resulting from a leading or
                  trailing colon, or two adjacent colons, is treated as a '.'
                  (the current directory).

     PGRP         The process ID of the shell's process group leader.

     PIPESTATUS   An array containing the errorlevel (exit status) codes, one
                  by one, of the last pipeline run in the foreground.

     PPID         The process ID of the shell's parent.

     PS1          The primary prompt for interactive shells.  Parameter, com-
                  mand, and arithmetic substitutions are performed, and '!' is
                  replaced with the current command number (see the ffcc command
                  below).  A literal '!' can be put in the prompt by placing
                  '!!' in PS1.

                  The default prompt is '$ ' for non-root users, '# ' for
                  root.  If mmkksshh is invoked by root and PS1 does not contain a
                  '#' character, the default value will be used even if PS1
                  already exists in the environment.

                  The mmkksshh distribution comes with a sample _d_o_t_._m_k_s_h_r_c con-
                  taining a sophisticated example, but you might like the fol-
                  lowing one (note that ${HOSTNAME:=$(hostname)} and the root-
                  vs-user distinguishing clause are (in this example) executed
                  at PS1 assignment time, while the $USER and $PWD are escaped
                  and thus will be evaluated each time a prompt is displayed):

                  PS1='${USER:=$(id -un)}'"@${HOSTNAME:=$(hostname)}:\$PWD $(
                          if (( USER_ID )); then print \$; else print \#; fi) "

                  Note that since the command-line editors try to figure out
                  how long the prompt is (so they know how far it is to the
                  edge of the screen), escape codes in the prompt tend to mess
                  things up.  You can tell the shell not to count certain
                  sequences (such as escape codes) by prefixing your prompt
                  with a character (such as Ctrl-A) followed by a carriage
                  return and then delimiting the escape codes with this char-
                  acter.  Any occurrences of that character in the prompt are
                  not printed.  By the way, don't blame me for this hack; it's
                  derived from the original ksh88(1), which did print the
                  delimiter character so you were out of luck if you did not
                  have any non-printing characters.

                  Since Backslashes and other special characters may be inter-
                  preted by the shell, to set PS1 either escape the backslash
                  itself, or use double quotes.  The latter is more practical.
                  This is a more complex example, avoiding to directly enter
                  special characters (for example with ^^VV in the emacs editing
                  mode), which embeds the current working directory, in
                  reverse video (colour would work, too), in the prompt
                  string:

                        x=$(print \\001)
                        PS1="$x$(print \\r)$x$(tput so)$x\$PWD$x$(tput se)$x> "

                  Due to a strong suggestion from David G. Korn, mmkksshh now also
                  supports the following form:

                        PS1=$'\1\r\1\e[7m\1$PWD\1\e[0m\1> '

     PS2          Secondary prompt string, by default '> ', used when more
                  input is needed to complete a command.

     PS3          Prompt used by the sseelleecctt statement when reading a menu
                  selection.  The default is '#? '.

     PS4          Used to prefix commands that are printed during execution
                  tracing (see the sseett --xx command below).  Parameter, command,
                  and arithmetic substitutions are performed before it is
                  printed.  The default is '+ '.  You may want to set it to
                  '[$EPOCHREALTIME] ' instead, to include timestamps.

     PWD          The current working directory.  May be unset or NULL if the
                  shell doesn't know where it is.

     RANDOM       Each time RANDOM is referenced, it is assigned a number
                  between 0 and 32767 from a Linear Congruential PRNG first.

     REPLY        Default parameter for the rreeaadd command if no names are
                  given.  Also used in sseelleecctt loops to store the value that is
                  read from standard input.

     SECONDS      The number of seconds since the shell started or, if the
                  parameter has been assigned an integer value, the number of
                  seconds since the assignment plus the value that was
                  assigned.

     TMOUT        If set to a positive integer in an interactive shell, it
                  specifies the maximum number of seconds the shell will wait
                  for input after printing the primary prompt (PS1).  If the
                  time is exceeded, the shell exits.

     TMPDIR       The directory temporary shell files are created in.  If this
                  parameter is not set, or does not contain the absolute path
                  of a writable directory, temporary files are created in
                  _/_t_m_p.

     USER_ID      The effective user id of the shell.

   TTiillddee eexxppaannssiioonn
     Tilde expansion which is done in parallel with parameter substitution, is
     done on words starting with an unquoted '~'.  The characters following
     the tilde, up to the first '/', if any, are assumed to be a login name.
     If the login name is empty, '+', or '-', the value of the HOME, PWD, or
     OLDPWD parameter is substituted, respectively.  Otherwise, the password
     file is searched for the login name, and the tilde expression is substi-
     tuted with the user's home directory.  If the login name is not found in
     the password file or if any quoting or parameter substitution occurs in
     the login name, no substitution is performed.

     In parameter assignments (such as those preceding a simple-command or
     those occurring in the arguments of aalliiaass, eexxppoorrtt, gglloobbaall, rreeaaddoonnllyy, and
     ttyyppeesseett), tilde expansion is done after any assignment (i.e. after the
     equals sign) or after an unquoted colon (':'); login names are also
     delimited by colons.

     The home directory of previously expanded login names are cached and re-
     used.  The aalliiaass --dd command may be used to list, change, and add to this
     cache (e.g. aalliiaass --dd ffaacc==//uussrr//llooccaall//ffaacciilliittiieess;; ccdd ~~ffaacc//bbiinn).

   BBrraaccee eexxppaannssiioonn ((aalltteerrnnaattiioonn))
     Brace expressions take the following form:

           _p_r_e_f_i_x{_s_t_r_1,...,_s_t_r_N}_s_u_f_f_i_x

     The expressions are expanded to _N words, each of which is the concatena-
     tion of _p_r_e_f_i_x, _s_t_ri, and _s_u_f_f_i_x (e.g. "a{c,b{X,Y},d}e" expands to four
     words: "ace", "abXe", "abYe", and "ade").  As noted in the example, brace
     expressions can be nested and the resulting words are not sorted.  Brace
     expressions must contain an unquoted comma (',') for expansion to occur
     (e.g. {{}} and {{ffoooo}} are not expanded).  Brace expansion is carried out
     after parameter substitution and before file name generation.

   FFiillee nnaammee ppaatttteerrnnss
     A file name pattern is a word containing one or more unquoted '?', '*',
     '+', '@', or '!' characters or "[..]" sequences.  Once brace expansion
     has been performed, the shell replaces file name patterns with the sorted
     names of all the files that match the pattern (if no files match, the
     word is left unchanged).  The pattern elements have the following mean-
     ing:

     ?       Matches any single character.

     *       Matches any sequence of octets.

     [..]    Matches any of the octets inside the brackets.  Ranges of octets
             can be specified by separating two octets by a '-' (e.g. "[a0-9]"
             matches the letter 'a' or any digit).  In order to represent
             itself, a '-' must either be quoted or the first or last octet in
             the octet list.  Similarly, a ']' must be quoted or the first
             octet in the list if it is to represent itself instead of the end
             of the list.  Also, a '!' appearing at the start of the list has
             special meaning (see below), so to represent itself it must be
             quoted or appear later in the list.

     [!..]   Like [..], except it matches any octet not inside the brackets.

     *(_p_a_t_t_e_r_n|...|_p_a_t_t_e_r_n)
             Matches any string of octets that matches zero or more occur-
             rences of the specified patterns.  Example: The pattern
             **((ffoooo|bbaarr)) matches the strings "", "foo", "bar", "foobarfoo",
             etc.

     +(_p_a_t_t_e_r_n|...|_p_a_t_t_e_r_n)
             Matches any string of octets that matches one or more occurrences
             of the specified patterns.  Example: The pattern ++((ffoooo|bbaarr))
             matches the strings "foo", "bar", "foobar", etc.

     ?(_p_a_t_t_e_r_n|...|_p_a_t_t_e_r_n)
             Matches the empty string or a string that matches one of the
             specified patterns.  Example: The pattern ??((ffoooo|bbaarr)) only matches
             the strings "", "foo", and "bar".

     @(_p_a_t_t_e_r_n|...|_p_a_t_t_e_r_n)
             Matches a string that matches one of the specified patterns.
             Example: The pattern @@((ffoooo|bbaarr)) only matches the strings "foo"
             and "bar".

     !(_p_a_t_t_e_r_n|...|_p_a_t_t_e_r_n)
             Matches any string that does not match one of the specified pat-
             terns.  Examples: The pattern !!((ffoooo|bbaarr)) matches all strings
             except "foo" and "bar"; the pattern !!((**)) matches no strings; the
             pattern !!((??))** matches all strings (think about it).

     Note that complicated globbing, especially with alternatives, is slow;
     using separate comparisons may (or may not) be faster.

     Note that mmkksshh (and ppddkksshh) never matches '.' and '..', but AT&T UNIX kksshh,
     Bourne sshh, and GNU bbaasshh do.

     Note that none of the above pattern elements match either a period ('.')
     at the start of a file name or a slash ('/'), even if they are explicitly
     used in a [..] sequence; also, the names '.' and '..' are never matched,
     even by the pattern '.*'.

     If the mmaarrkkddiirrss option is set, any directories that result from file name
     generation are marked with a trailing '/'.

   IInnppuutt//oouuttppuutt rreeddiirreeccttiioonn
     When a command is executed, its standard input, standard output, and
     standard error (file descriptors 0, 1, and 2, respectively) are normally
     inherited from the shell.  Three exceptions to this are commands in pipe-
     lines, for which standard input and/or standard output are those set up
     by the pipeline, asynchronous commands created when job control is dis-
     abled, for which standard input is initially set to be from _/_d_e_v_/_n_u_l_l,
     and commands for which any of the following redirections have been speci-
     fied:

     > _f_i_l_e      Standard output is redirected to _f_i_l_e.  If _f_i_l_e does not
                 exist, it is created; if it does exist, is a regular file,
                 and the nnoocclloobbbbeerr option is set, an error occurs; otherwise,
                 the file is truncated.  Note that this means the command ccmmdd
                 <<ffoooo >>ffoooo will open _f_o_o for reading and then truncate it when
                 it opens it for writing, before _c_m_d gets a chance to actually
                 read _f_o_o.

     >| _f_i_l_e     Same as >>, except the file is truncated, even if the
                 nnoocclloobbbbeerr option is set.

     >> _f_i_l_e     Same as >>, except if _f_i_l_e exists it is appended to instead of
                 being truncated.  Also, the file is opened in append mode, so
                 writes always go to the end of the file (see open(2)).

     < _f_i_l_e      Standard input is redirected from _f_i_l_e, which is opened for
                 reading.

     <> _f_i_l_e     Same as <<, except the file is opened for reading and writing.

     << _m_a_r_k_e_r   After reading the command line containing this kind of redi-
                 rection (called a "here document"), the shell copies lines
                 from the command source into a temporary file until a line
                 matching _m_a_r_k_e_r is read.  When the command is executed, stan-
                 dard input is redirected from the temporary file.  If _m_a_r_k_e_r
                 contains no quoted characters, the contents of the temporary
                 file are processed as if enclosed in double quotes each time
                 the command is executed, so parameter, command, and arith-
                 metic substitutions are performed, along with backslash ('\')
                 escapes for '$', '`', '\', and '\newline', but not for '"'.
                 If multiple here documents are used on the same command line,
                 they are saved in order.

                 If no _m_a_r_k_e_r is given, the here document ends at the next <<<<
                 and substitution will be performed.  If _m_a_r_k_e_r is only a set
                 of either single "''" or double '""' quotes with nothing in
                 between, the here document ends at the next empty line and
                 substitution will not be performed.

     <<- _m_a_r_k_e_r  Same as <<<<, except leading tabs are stripped from lines in
                 the here document.

     <<< _w_o_r_d    Same as <<<<, except that _w_o_r_d _i_s the here document.  This is
                 called a here string.

     <& _f_d       Standard input is duplicated from file descriptor _f_d.  _f_d can
                 be a number, indicating the number of an existing file
                 descriptor; the letter 'p', indicating the file descriptor
                 associated with the output of the current co-process; or the
                 character '-', indicating standard input is to be closed.
                 Note that _f_d is limited to a single digit in most shell
                 implementations.

     >& _f_d       Same as <<&&, except the operation is done on standard output.

     &> _f_i_l_e     Same as >> _f_i_l_e _2_>_&_1.  This is a GNU bbaasshh extension supported
                 by mmkksshh which also supports the preceding explicit fd number,
                 for example, 33&&>> _f_i_l_e is the same as 33>> _f_i_l_e _2_>_&_3 in mmkksshh but
                 a syntax error in GNU bbaasshh.  Setting the --oo _p_o_s_i_x or --oo _s_h
                 shell options disable parsing of this redirection; it's a
                 compatibility feature to legacy scripts, to not be used when
                 writing new shell code.

     &>| _f_i_l_e, &>> _f_i_l_e, &>& _f_d
                 Same as >>| _f_i_l_e, >>>> _f_i_l_e, or >>&& _f_d, followed by 22>>&&11, as
                 above.  These are mmkksshh extensions.

     In any of the above redirections, the file descriptor that is redirected
     (i.e. standard input or standard output) can be explicitly given by pre-
     ceding the redirection with a number (portably, only a single digit).
     Parameter, command, and arithmetic substitutions, tilde substitutions,
     and (if the shell is interactive) file name generation are all performed
     on the _f_i_l_e, _m_a_r_k_e_r, and _f_d arguments of redirections.  Note, however,
     that the results of any file name generation are only used if a single
     file is matched; if multiple files match, the word with the expanded file
     name generation characters is used.  Note that in restricted shells,
     redirections which can create files cannot be used.

     For simple-commands, redirections may appear anywhere in the command; for
     compound-commands (iiff statements, etc.), any redirections must appear at
     the end.  Redirections are processed after pipelines are created and in
     the order they are given, so the following will print an error with a
     line number prepended to it:

           $ cat /foo/bar 2>&1 >/dev/null | pr -n -t

     File descriptors created by input/output redirections are private to the
     Korn shell, but passed to sub-processes if --oo ppoossiixx or --oo sshh is set.

   AArriitthhmmeettiicc eexxpprreessssiioonnss
     Integer arithmetic expressions can be used with the lleett command, inside
     $((..)) expressions, inside array references (e.g. _n_a_m_e[_e_x_p_r]), as
     numeric arguments to the tteesstt command, and as the value of an assignment
     to an integer parameter.  _W_a_r_n_i_n_g: This also affects implicit conversion
     to integer, for example as done by the lleett command.  _N_e_v_e_r use unchecked
     user input, e.g. from the environment, in arithmetics!

     Expressions are calculated using signed arithmetic and the _m_k_s_h___a_r_i___t
     type (a 32-bit signed integer), unless they begin with a sole '#' charac-
     ter, in which case they use _m_k_s_h___u_a_r_i___t (a 32-bit unsigned integer).

     Expressions may contain alpha-numeric parameter identifiers, array refer-
     ences, and integer constants and may be combined with the following C
     operators (listed and grouped in increasing order of precedence):

     Unary operators:

           + - ! ~ ++ --

     Binary operators:

           ,
           = += -= *= /= %= <<<= >>>= <<= >>= &= ^= |=
           ||
           &&
           |
           ^
           &
           == !=
           < <= > >=
           <<< >>> << >>
           + -
           * / %

     Ternary operators:

           ?: (precedence is immediately higher than assignment)

     Grouping operators:

           ( )

     Integer constants and expressions are calculated using an exactly 32-bit
     wide, signed or unsigned, type with silent wraparound on integer over-
     flow.  Integer constants may be specified with arbitrary bases using the
     notation _b_a_s_e#_n_u_m_b_e_r, where _b_a_s_e is a decimal integer specifying the
     base, and _n_u_m_b_e_r is a number in the specified base.  Additionally,
     base-16 integers may be specified by prefixing them with '0x'
     (case-insensitive) in all forms of arithmetic expressions, except as
     numeric arguments to the tteesstt built-in command.  Prefixing numbers with a
     sole digit zero ('0') leads to the shell interpreting it as base-8
     (octal) integer in ppoossiixx mode _o_n_l_y; historically, (pd)ksh has never done
     so either anyway, and it's unsafe to do that, but POSIX demands it nowa-
     days.  As a special mmkksshh extension, numbers to the base of one are
     treated as either (8-bit transparent) ASCII or Unicode codepoints,
     depending on the shell's uuttff88--mmooddee flag (current setting).  The AT&T UNIX
     kksshh9933 syntax of "'x'" instead of "1#x" is also supported.  Note that NUL
     bytes (integral value of zero) cannot be used.  An unset or empty parame-
     ter evaluates to 0 in integer context.  In Unicode mode, raw octets are
     mapped into the range EF80..EFFF as in OPTU-8, which is in the PUA and
     has been assigned by CSUR for this use.  If more than one octet in ASCII
     mode, or a sequence of more than one octet not forming a valid and mini-
     mal CESU-8 sequence is passed, the behaviour is undefined (usually, the
     shell aborts with a parse error, but rarely, it succeeds, e.g. on the
     sequence C2 20).  That's why you should always use ASCII mode unless you
     know that the input is well-formed UTF-8 in the range of 0000..FFFD.

     The operators are evaluated as follows:

           unary +
                   Result is the argument (included for completeness).

           unary -
                   Negation.

           !       Logical NOT; the result is 1 if argument is zero, 0 if not.

           ~       Arithmetic (bit-wise) NOT.

           ++      Increment; must be applied to a parameter (not a literal or
                   other expression).  The parameter is incremented by 1.
                   When used as a prefix operator, the result is the incre-
                   mented value of the parameter; when used as a postfix oper-
                   ator, the result is the original value of the parameter.

           --      Similar to ++++, except the parameter is decremented by 1.

           ,       Separates two arithmetic expressions; the left-hand side is
                   evaluated first, then the right.  The result is the value
                   of the expression on the right-hand side.

           =       Assignment; the variable on the left is set to the value on
                   the right.

           += -= *= /= %= <<<= >>>= <<= >>= &= ^= |=
                   Assignment operators.  <_v_a_r><_o_p>=<_e_x_p_r> is the same as
                   <_v_a_r>=<_v_a_r><_o_p><_e_x_p_r>, with any operator precedence in
                   <_e_x_p_r> preserved.  For example, "var1 *= 5 + 3" is the same
                   as specifying "var1 = var1 * (5 + 3)".

           ||      Logical OR; the result is 1 if either argument is non-zero,
                   0 if not.  The right argument is evaluated only if the left
                   argument is zero.

           &&      Logical AND; the result is 1 if both arguments are non-
                   zero, 0 if not.  The right argument is evaluated only if
                   the left argument is non-zero.

           |       Arithmetic (bit-wise) OR.

           ^       Arithmetic (bit-wise) XOR (exclusive-OR).

           &       Arithmetic (bit-wise) AND.

           ==      Equal; the result is 1 if both arguments are equal, 0 if
                   not.

           !=      Not equal; the result is 0 if both arguments are equal, 1
                   if not.

           <       Less than; the result is 1 if the left argument is less
                   than the right, 0 if not.

           <= > >=
                   Less than or equal, greater than, greater than or equal.
                   See <<.

           <<< >>>
                   Rotate left (right); the result is similar to shift (see
                   <<<<) except that the bits shifted out at one end are shifted
                   in at the other end, instead of zero or sign bits.

           << >>   Shift left (right); the result is the left argument with
                   its bits shifted left (right) by the amount given in the
                   right argument.

           + - * /
                   Addition, subtraction, multiplication, and division.

           %       Remainder; the result is the symmetric remainder of the
                   division of the left argument by the right.  To get the
                   mathematical modulus of "a mmoodd b", use the formula "(a % b
                   + b) % b".

           <_a_r_g_1>?<_a_r_g_2>:<_a_r_g_3>
                   If <_a_r_g_1> is non-zero, the result is <_a_r_g_2>; otherwise the
                   result is <_a_r_g_3>.  The non-result argument is not evalu-
                   ated.

   CCoo--pprroocceesssseess
     A co-process (which is a pipeline created with the '|&' operator) is an
     asynchronous process that the shell can both write to (using pprriinntt --pp)
     and read from (using rreeaadd --pp).  The input and output of the co-process
     can also be manipulated using >>&&pp and <<&&pp redirections, respectively.
     Once a co-process has been started, another can't be started until the
     co-process exits, or until the co-process's input has been redirected
     using an eexxeecc _n>>&&pp redirection.  If a co-process's input is redirected in
     this way, the next co-process to be started will share the output with
     the first co-process, unless the output of the initial co-process has
     been redirected using an eexxeecc _n<<&&pp redirection.

     Some notes concerning co-processes:

     ++oo   The only way to close the co-process's input (so the co-process reads
         an end-of-file) is to redirect the input to a numbered file descrip-
         tor and then close that file descriptor: eexxeecc 33>>&&pp;; eexxeecc 33>>&&--

     ++oo   In order for co-processes to share a common output, the shell must
         keep the write portion of the output pipe open.  This means that end-
         of-file will not be detected until all co-processes sharing the co-
         process's output have exited (when they all exit, the shell closes
         its copy of the pipe).  This can be avoided by redirecting the output
         to a numbered file descriptor (as this also causes the shell to close
         its copy).  Note that this behaviour is slightly different from the
         original Korn shell which closes its copy of the write portion of the
         co-process output when the most recently started co-process (instead
         of when all sharing co-processes) exits.

     ++oo   pprriinntt --pp will ignore SIGPIPE signals during writes if the signal is
         not being trapped or ignored; the same is true if the co-process
         input has been duplicated to another file descriptor and pprriinntt --uu_n is
         used.

   FFuunnccttiioonnss
     Functions are defined using either Korn shell ffuunnccttiioonn _f_u_n_c_t_i_o_n_-_n_a_m_e syn-
     tax or the Bourne/POSIX shell _f_u_n_c_t_i_o_n_-_n_a_m_e() syntax (see below for the
     difference between the two forms).  Functions are like .-scripts (i.e.
     scripts sourced using the '.' built-in) in that they are executed in the
     current environment.  However, unlike .-scripts, shell arguments (i.e.
     positional parameters $1, $2, etc.) are never visible inside them.  When
     the shell is determining the location of a command, functions are
     searched after special built-in commands, before builtins and the PATH is
     searched.

     An existing function may be deleted using uunnsseett --ff _f_u_n_c_t_i_o_n_-_n_a_m_e.  A list
     of functions can be obtained using ttyyppeesseett ++ff and the function defini-
     tions can be listed using ttyyppeesseett --ff.  The aauuttoollooaadd command (which is an
     alias for ttyyppeesseett --ffuu) may be used to create undefined functions: when an
     undefined function is executed, the shell searches the path specified in
     the FPATH parameter for a file with the same name as the function which,
     if found, is read and executed.  If after executing the file the named
     function is found to be defined, the function is executed; otherwise, the
     normal command search is continued (i.e. the shell searches the regular
     built-in command table and PATH).  Note that if a command is not found
     using PATH, an attempt is made to autoload a function using FPATH (this
     is an undocumented feature of the original Korn shell).

     Functions can have two attributes, "trace" and "export", which can be set
     with ttyyppeesseett --fftt and ttyyppeesseett --ffxx, respectively.  When a traced function
     is executed, the shell's xxttrraaccee option is turned on for the function's
     duration.  The "export" attribute of functions is currently not used.  In
     the original Korn shell, exported functions are visible to shell scripts
     that are executed.

     Since functions are executed in the current shell environment, parameter
     assignments made inside functions are visible after the function com-
     pletes.  If this is not the desired effect, the ttyyppeesseett command can be
     used inside a function to create a local parameter.  Note that AT&T UNIX
     kksshh9933 uses static scoping (one global scope, one local scope per func-
     tion) and allows local variables only on Korn style functions, whereas
     mmkksshh uses dynamic scoping (nested scopes of varying locality).  Note that
     special parameters (e.g. $$$$, $$!!) can't be scoped in this way.

     The exit status of a function is that of the last command executed in the
     function.  A function can be made to finish immediately using the rreettuurrnn
     command; this may also be used to explicitly specify the exit status.

     Functions defined with the ffuunnccttiioonn reserved word are treated differently
     in the following ways from functions defined with the (()) notation:

     ++oo   The $0 parameter is set to the name of the function (Bourne-style
         functions leave $0 untouched).

     ++oo   Parameter assignments preceding function calls are not kept in the
         shell environment (executing Bourne-style functions will keep assign-
         ments).

     ++oo   OPTIND is saved/reset and restored on entry and exit from the func-
         tion so ggeettooppttss can be used properly both inside and outside the
         function (Bourne-style functions leave OPTIND untouched, so using
         ggeettooppttss inside a function interferes with using ggeettooppttss outside the
         function).

     ++oo   Shell options (sseett --oo) have local scope, i.e. changes inside a func-
         tion are reset upon its exit.

     In the future, the following differences may also be added:

     ++oo   A separate trap/signal environment will be used during the execution
         of functions.  This will mean that traps set inside a function will
         not affect the shell's traps and signals that are not ignored in the
         shell (but may be trapped) will have their default effect in a func-
         tion.

     ++oo   The EXIT trap, if set in a function, will be executed after the func-
         tion returns.

   CCoommmmaanndd eexxeeccuuttiioonn
     After evaluation of command-line arguments, redirections, and parameter
     assignments, the type of command is determined: a special built-in com-
     mand, a function, a normal builtin, or the name of a file to execute
     found using the PATH parameter.  The checks are made in the above order.
     Special built-in commands differ from other commands in that the PATH
     parameter is not used to find them, an error during their execution can
     cause a non-interactive shell to exit, and parameter assignments that are
     specified before the command are kept after the command completes.  Regu-
     lar built-in commands are different only in that the PATH parameter is
     not used to find them.

     The original kksshh and POSIX differ somewhat in which commands are consid-
     ered special or regular.

     POSIX special built-in utilities:

     .., ::, bbrreeaakk, ccoonnttiinnuuee, eevvaall, eexxeecc, eexxiitt, eexxppoorrtt, rreeaaddoonnllyy, rreettuurrnn, sseett,
     sshhiifftt, ttiimmeess, ttrraapp, uunnsseett

     Additional mmkksshh commands keeping assignments:

     bbuuiillttiinn, gglloobbaall, ttyyppeesseett, wwaaiitt

     Builtins that are not special:

     [, aalliiaass, bbgg, bbiinndd, ccaatt, ccdd, ccoommmmaanndd, eecchhoo, ffaallssee, ffcc, ffgg, ggeettooppttss, jjoobbss,
     kkiillll, lleett, mmkknnoodd, pprriinntt, ppwwdd, rreeaadd, rreeaallppaatthh, rreennaammee, sslleeeepp, ssuussppeenndd,
     tteesstt, ttrruuee, uulliimmiitt, uummaasskk, uunnaalliiaass, wwhheennccee

     Once the type of command has been determined, any command-line parameter
     assignments are performed and exported for the duration of the command.

     The following describes the special and regular built-in commands:

     .. _f_i_l_e [_a_r_g _._._.]
            This is called the "dot" command.  Execute the commands in _f_i_l_e in
            the current environment.  The file is searched for in the directo-
            ries of PATH.  If arguments are given, the positional parameters
            may be used to access them while _f_i_l_e is being executed.  If no
            arguments are given, the positional parameters are those of the
            environment the command is used in.

     :: [_._._.]
            The null command.  Exit status is set to zero.

     [[ _e_x_p_r_e_s_s_i_o_n ]]
            See tteesstt.

     aalliiaass [--dd | --tt [--rr] | ++--xx] [--pp] [++] [_n_a_m_e [=_v_a_l_u_e] _._._.]
            Without arguments, aalliiaass lists all aliases.  For any name without
            a value, the existing alias is listed.  Any name with a value
            defines an alias (see _A_l_i_a_s_e_s above).

            When listing aliases, one of two formats is used.  Normally,
            aliases are listed as _n_a_m_e=_v_a_l_u_e, where _v_a_l_u_e is quoted.  If
            options were preceded with '+', or a lone '+' is given on the com-
            mand line, only _n_a_m_e is printed.

            The --dd option causes directory aliases which are used in tilde
            expansion to be listed or set (see _T_i_l_d_e _e_x_p_a_n_s_i_o_n above).

            If the --pp option is used, each alias is prefixed with the string
            "alias ".

            The --tt option indicates that tracked aliases are to be listed/set
            (values specified on the command line are ignored for tracked
            aliases).  The --rr option indicates that all tracked aliases are to
            be reset.

            The --xx option sets (++xx clears) the export attribute of an alias,
            or, if no names are given, lists the aliases with the export
            attribute (exporting an alias has no effect).

     bbgg [_j_o_b _._._.]
            Resume the specified stopped job(s) in the background.  If no jobs
            are specified, %%++ is assumed.  See _J_o_b _c_o_n_t_r_o_l below for more
            information.

     bbiinndd [--ll]
            The current bindings are listed.  If the --ll flag is given, bbiinndd
            instead lists the names of the functions to which keys may be
            bound.  See _E_m_a_c_s _e_d_i_t_i_n_g _m_o_d_e for more information.

     bbiinndd [--mm] _s_t_r_i_n_g=[_s_u_b_s_t_i_t_u_t_e] _._._.
     bbiinndd _s_t_r_i_n_g=[_e_d_i_t_i_n_g_-_c_o_m_m_a_n_d] _._._.
            The specified editing command is bound to the given _s_t_r_i_n_g, which
            should consist of a control character optionally preceded by one
            of the two prefix characters and optionally succeded by a tilde
            character.  Future input of the _s_t_r_i_n_g will cause the editing com-
            mand to be immediately invoked.  If the --mm flag is given, the
            specified input _s_t_r_i_n_g will afterwards be immediately replaced by
            the given _s_u_b_s_t_i_t_u_t_e string which may contain editing commands but
            not other macros.  If a tilde postfix is given, a tilde trailing
            the one or two prefices and the control character is ignored, any
            other trailing character will be processed afterwards.

            Control characters may be written using caret notation i.e. ^X
            represents Ctrl-X.  Note that although only two prefix characters
            (usually ESC and ^X) are supported, some multi-character sequences
            can be supported.

            The following default bindings show how the arrow keys, the home,
            end and delete key on a BSD wsvt25, xterm-xfree86 or GNU screen
            terminal are bound (of course some escape sequences won't work out
            quite this nicely):

                  bind '^X'=prefix-2
                  bind '^[['=prefix-2
                  bind '^XA'=up-history
                  bind '^XB'=down-history
                  bind '^XC'=forward-char
                  bind '^XD'=backward-char
                  bind '^X1~'=beginning-of-line
                  bind '^X7~'=beginning-of-line
                  bind '^XH'=beginning-of-line
                  bind '^X4~'=end-of-line
                  bind '^X8~'=end-of-line
                  bind '^XF'=end-of-line
                  bind '^X3~'=delete-char-forward

     bbrreeaakk [_l_e_v_e_l]
            Exit the _l_e_v_e_lth inner-most ffoorr, sseelleecctt, uunnttiill, or wwhhiillee loop.
            _l_e_v_e_l defaults to 1.

     bbuuiillttiinn [----] _c_o_m_m_a_n_d [_a_r_g _._._.]
            Execute the built-in command _c_o_m_m_a_n_d.

     ccaatt [--uu] [_f_i_l_e _._._.]
            Read files sequentially, in command line order, and write them to
            standard output.  If a _f_i_l_e is a single dash ('-') or absent, read
            from standard input.  For direct builtin calls, the POSIX --uu
            option is supported as a no-op.  For calls from shell, if any
            options are given, an external cat(1) utility is preferred over
            the builtin.

     ccdd [--LL] [_d_i_r]
     ccdd --PP [--ee] [_d_i_r]
     cchhddiirr [--eeLLPP] [_d_i_r]
            Set the working directory to _d_i_r.  If the parameter CDPATH is set,
            it lists the search path for the directory containing _d_i_r.  A NULL
            path means the current directory.  If _d_i_r is found in any compo-
            nent of the CDPATH search path other than the NULL path, the name
            of the new working directory will be written to standard output.
            If _d_i_r is missing, the home directory HOME is used.  If _d_i_r is
            '-', the previous working directory is used (see the OLDPWD param-
            eter).

            If the --LL option (logical path) is used or if the pphhyyssiiccaall option
            isn't set (see the sseett command below), references to '..' in _d_i_r
            are relative to the path used to get to the directory.  If the --PP
            option (physical path) is used or if the pphhyyssiiccaall option is set,
            '..' is relative to the filesystem directory tree.  The PWD and
            OLDPWD parameters are updated to reflect the current and old work-
            ing directory, respectively.  If the --ee option is set for physical
            filesystem traversal, and PWD could not be set, the exit code is
            1; greater than 1 if an error occurred, 0 otherwise.

     ccdd [--eeLLPP] _o_l_d _n_e_w
     cchhddiirr [--eeLLPP] _o_l_d _n_e_w
            The string _n_e_w is substituted for _o_l_d in the current directory,
            and the shell attempts to change to the new directory.

     ccoommmmaanndd [--ppVVvv] _c_m_d [_a_r_g _._._.]
            If neither the --vv nor --VV option is given, _c_m_d is executed exactly
            as if ccoommmmaanndd had not been specified, with two exceptions:
            firstly, _c_m_d cannot be a shell function; and secondly, special
            built-in commands lose their specialness (i.e. redirection and
            utility errors do not cause the shell to exit, and command assign-
            ments are not permanent).

            If the --pp option is given, a default search path is used instead
            of the current value of PATH, the actual value of which is system
            dependent.

            If the --vv option is given, instead of executing _c_m_d, information
            about what would be executed is given (and the same is done for
            _a_r_g _._._.).  For builtins, functions and keywords, their names are
            simply printed; for aliases, a command that defines them is
            printed; for utilities found by searching the PATH parameter, the
            full path of the command is printed.  If no command is found (i.e.
            the path search fails), nothing is printed and ccoommmmaanndd exits with
            a non-zero status.  The --VV option is like the --vv option, except it
            is more verbose.

     ccoonnttiinnuuee [_l_e_v_e_l]
            Jumps to the beginning of the _l_e_v_e_lth inner-most ffoorr, sseelleecctt,
            uunnttiill, or wwhhiillee loop.  _l_e_v_e_l defaults to 1.

     eecchhoo [--EEeenn] [_a_r_g _._._.]
            _W_a_r_n_i_n_g_: this utility is not portable; use the Korn shell builtin
            pprriinntt instead.

            Prints its arguments (separated by spaces) followed by a newline,
            to the standard output.  The newline is suppressed if any of the
            arguments contain the backslash sequence '\c'.  See the pprriinntt com-
            mand below for a list of other backslash sequences that are recog-
            nised.

            The options are provided for compatibility with BSD shell scripts.
            The --nn option suppresses the trailing newline, --ee enables back-
            slash interpretation (a no-op, since this is normally done), and
            --EE suppresses backslash interpretation.

            If the ppoossiixx or sshh option is set or this is a direct builtin call,
            only the first argument is treated as an option, and only if it is
            exactly "--nn".  Backslash interpretation is disabled.

     eevvaall _c_o_m_m_a_n_d _._._.
            The arguments are concatenated (with spaces between them) to form
            a single string which the shell then parses and executes in the
            current environment.

     eexxeecc [--aa _a_r_g_v_0] [--cc] [_c_o_m_m_a_n_d [_a_r_g _._._.]]
            The command is executed without forking, replacing the shell
            process.  This is currently absolute, i.e. eexxeecc never returns,
            even if the _c_o_m_m_a_n_d is not found.  The --aa option permits setting a
            different argv[0] value, and --cc clears the environment before exe-
            cuting the child process, except for the _ variable and direct
            assignments.

            If no command is given except for I/O redirection, the I/O redi-
            rection is permanent and the shell is not replaced.  Any file
            descriptors greater than 2 which are opened or dup(2)'d in this
            way are not made available to other executed commands (i.e. com-
            mands that are not built-in to the shell).  Note that the Bourne
            shell differs here; it does pass these file descriptors on.

     eexxiitt [_s_t_a_t_u_s]
            The shell exits with the specified exit status.  If _s_t_a_t_u_s is not
            specified, the exit status is the current value of the $$?? parame-
            ter.

     eexxppoorrtt [--pp] [_p_a_r_a_m_e_t_e_r[=_v_a_l_u_e]]
            Sets the export attribute of the named parameters.  Exported
            parameters are passed in the environment to executed commands.  If
            values are specified, the named parameters are also assigned.

            If no parameters are specified, all parameters with the export
            attribute set are printed one per line; either their names, or, if
            a '-' with no option letter is specified, name=value pairs, or,
            with --pp, eexxppoorrtt commands suitable for re-entry.

     ffaallssee  A command that exits with a non-zero status.

     ffcc [--ee _e_d_i_t_o_r | --ll [--nn]] [--rr] [_f_i_r_s_t [_l_a_s_t]]
            _f_i_r_s_t and _l_a_s_t select commands from the history.  Commands can be
            selected by history number (negative numbers go backwards from the
            current, most recent, line) or a string specifying the most recent
            command starting with that string.  The --ll option lists the com-
            mand on standard output, and --nn inhibits the default command num-
            bers.  The --rr option reverses the order of the list.  Without --ll,
            the selected commands are edited by the editor specified with the
            --ee option, or if no --ee is specified, the editor specified by the
            FCEDIT parameter (if this parameter is not set, _/_b_i_n_/_e_d is used),
            and then executed by the shell.

     ffcc --ee -- | --ss [--gg] [_o_l_d=_n_e_w] [_p_r_e_f_i_x]
            Re-execute the selected command (the previous command by default)
            after performing the optional substitution of _o_l_d with _n_e_w.  If --gg
            is specified, all occurrences of _o_l_d are replaced with _n_e_w.  The
            meaning of --ee -- and --ss is identical: re-execute the selected com-
            mand without invoking an editor.  This command is usually accessed
            with the predefined: aalliiaass rr==''ffcc --ee --''

     ffgg [_j_o_b _._._.]
            Resume the specified job(s) in the foreground.  If no jobs are
            specified, %%++ is assumed.  See _J_o_b _c_o_n_t_r_o_l below for more informa-
            tion.

     ggeettooppttss _o_p_t_s_t_r_i_n_g _n_a_m_e [_a_r_g _._._.]
            Used by shell procedures to parse the specified arguments (or
            positional parameters, if no arguments are given) and to check for
            legal options.  _o_p_t_s_t_r_i_n_g contains the option letters that ggeettooppttss
            is to recognise.  If a letter is followed by a colon, the option
            is expected to have an argument.  Options that do not take argu-
            ments may be grouped in a single argument.  If an option takes an
            argument and the option character is not the last character of the
            argument it is found in, the remainder of the argument is taken to
            be the option's argument; otherwise, the next argument is the
            option's argument.

            Each time ggeettooppttss is invoked, it places the next option in the
            shell parameter _n_a_m_e and the index of the argument to be processed
            by the next call to ggeettooppttss in the shell parameter OPTIND.  If the
            option was introduced with a '+', the option placed in _n_a_m_e is
            prefixed with a '+'.  When an option requires an argument, ggeettooppttss
            places it in the shell parameter OPTARG.

            When an illegal option or a missing option argument is encoun-
            tered, a question mark or a colon is placed in _n_a_m_e (indicating an
            illegal option or missing argument, respectively) and OPTARG is
            set to the option character that caused the problem.  Furthermore,
            if _o_p_t_s_t_r_i_n_g does not begin with a colon, a question mark is
            placed in _n_a_m_e, OPTARG is unset, and an error message is printed
            to standard error.

            When the end of the options is encountered, ggeettooppttss exits with a
            non-zero exit status.  Options end at the first (non-option argu-
            ment) argument that does not start with a '-', or when a '--'
            argument is encountered.

            Option parsing can be reset by setting OPTIND to 1 (this is done
            automatically whenever the shell or a shell procedure is invoked).

            Warning: Changing the value of the shell parameter OPTIND to a
            value other than 1, or parsing different sets of arguments without
            resetting OPTIND, may lead to unexpected results.

     global _._._.
            See ttyyppeesseett.

     hhaasshh [--rr] [_n_a_m_e _._._.]
            Without arguments, any hashed executable command pathnames are
            listed.  The --rr option causes all hashed commands to be removed
            from the hash table.  Each _n_a_m_e is searched as if it were a com-
            mand name and added to the hash table if it is an executable com-
            mand.

     jjoobbss [--llnnpp] [_j_o_b _._._.]
            Display information about the specified job(s); if no jobs are
            specified, all jobs are displayed.  The --nn option causes informa-
            tion to be displayed only for jobs that have changed state since
            the last notification.  If the --ll option is used, the process ID
            of each process in a job is also listed.  The --pp option causes
            only the process group of each job to be printed.  See _J_o_b _c_o_n_t_r_o_l
            below for the format of _j_o_b and the displayed job.

     kkiillll [--ss _s_i_g_n_a_m_e | -_s_i_g_n_u_m | -_s_i_g_n_a_m_e] { _j_o_b | _p_i_d | _p_g_r_p } _._._.
            Send the specified signal to the specified jobs, process IDs, or
            process groups.  If no signal is specified, the TERM signal is
            sent.  If a job is specified, the signal is sent to the job's
            process group.  See _J_o_b _c_o_n_t_r_o_l below for the format of _j_o_b.

     kkiillll --ll [_e_x_i_t_-_s_t_a_t_u_s _._._.]
            Print the signal name corresponding to _e_x_i_t_-_s_t_a_t_u_s.  If no argu-
            ments are specified, a list of all the signals, their numbers, and
            a short description of them are printed.

     lleett [_e_x_p_r_e_s_s_i_o_n _._._.]
            Each expression is evaluated (see _A_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n_s above).
            If all expressions are successfully evaluated, the exit status is
            0 (1) if the last expression evaluated to non-zero (zero).  If an
            error occurs during the parsing or evaluation of an expression,
            the exit status is greater than 1.  Since expressions may need to
            be quoted, (( _e_x_p_r )) is syntactic sugar for let "_e_x_p_r".

     lleett]]   Internally used alias for lleett.

     mmkknnoodd [--mm _m_o_d_e] _n_a_m_e bb|cc _m_a_j_o_r _m_i_n_o_r
     mmkknnoodd [--mm _m_o_d_e] _n_a_m_e pp
            Create a device special file.  The file type may be bb (block type
            device), cc (character type device), or pp (named pipe, FIFO).  The
            file created may be modified according to its _m_o_d_e (via the --mm
            option), _m_a_j_o_r (major device number), and _m_i_n_o_r (minor device num-
            ber).

            See mknod(8) for further information.  This is not normally part
            of mmkksshh; however, distributors may have added this as builtin as a
            speed hack.

     pprriinntt [--nnpprrssuu[_n] | --RR [--eenn]] [_a_r_g_u_m_e_n_t _._._.]
            pprriinntt prints its arguments on the standard output, separated by
            spaces and terminated with a newline.  The --nn option suppresses
            the newline.  By default, certain C escapes are translated.  These
            include these mentioned in _B_a_c_k_s_l_a_s_h _e_x_p_a_n_s_i_o_n above, as well as
            '\c', which is equivalent to using the --nn option.  Backslash
            expansion may be inhibited with the --rr option.  The --ss option
            prints to the history file instead of standard output; the --uu
            option prints to file descriptor _n (_n defaults to 1 if omitted);
            and the --pp option prints to the co-process (see _C_o_-_p_r_o_c_e_s_s_e_s
            above).

            The --RR option is used to emulate, to some degree, the BSD echo(1)
            command which does not process '\' sequences unless the --ee option
            is given.  As above, the --nn option suppresses the trailing new-
            line.

     pprriinnttff _f_o_r_m_a_t [_a_r_g_u_m_e_n_t_s _._._.]
            Formatted output.  Approximately the same as the printf(1), util-
            ity, except it uses the same _B_a_c_k_s_l_a_s_h _e_x_p_a_n_s_i_o_n and I/O code and
            does not handle floating point as the rest of mmkksshh.  An external
            utility is preferred over the builtin.  This is not normally part
            of mmkksshh; however, distributors may have added this as builtin as a
            speed hack.  Do not use in new code.

     ppwwdd [--LLPP]
            Print the present working directory.  If the --LL option is used or
            if the pphhyyssiiccaall option isn't set (see the sseett command below), the
            logical path is printed (i.e. the path used to ccdd to the current
            directory).  If the --PP option (physical path) is used or if the
            pphhyyssiiccaall option is set, the path determined from the filesystem
            (by following '..' directories to the root directory) is printed.

     rreeaadd [--AA | --aa] [--dd _x] [--NN _z | --nn _z] [--pp | --uu[_n]] [--tt _n] [--rrss] [_p _._._.]
            Reads a line of input, separates the input into fields using the
            IFS parameter (see _S_u_b_s_t_i_t_u_t_i_o_n above), and assigns each field to
            the specified parameters _p.  If no parameters are specified, the
            REPLY parameter is used to store the result.  With the --AA and --aa
            options, only no or one parameter is accepted.  If there are more
            parameters than fields, the extra parameters are set to the empty
            string or 0; if there are more fields than parameters, the last
            parameter is assigned the remaining fields (including the word
            separators).

            The options are as follows:

            --AA     Store the result into the parameter _p (or REPLY) as array
                   of words.

            --aa     Store the result without word splitting into the parameter
                   _p (or REPLY) as array of characters (wide characters if the
                   uuttff88--mmooddee option is enacted, octets otherwise).

            --dd _x   Use the first byte of _x, NUL if empty, instead of the ASCII
                   newline character as input line delimiter.

            --NN _z   Instead of reading till end-of-line, read exactly _z bytes.
                   If EOF or a timeout occurs, a partial read is returned with
                   exit status 1.

            --nn _z   Instead of reading till end-of-line, read up to _z bytes but
                   return as soon as any bytes are read, e.g. from a slow ter-
                   minal device, or if EOF or a timeout occurs.

            --pp     Read from the currently active co-process, see _C_o_-_p_r_o_c_e_s_s_e_s
                   above for details on this.

            --uu[_n]  Read from the file descriptor _n (defaults to 0, i.e. stan-
                   dard input).  The argument must immediately follow the
                   option character.

            --tt _n   Interrupt reading after _n seconds (specified as positive
                   decimal value with an optional fractional part).  The exit
                   status of rreeaadd is 1 if the timeout occurred, but partial
                   reads may still be returned.

            --rr     Normally, the ASCII backslash character escapes the special
                   meaning of the following character and is stripped from the
                   input; rreeaadd does not stop when encountering a backslash-
                   newline sequence and does not store that newline in the
                   result.  This option enables raw mode, in which backslashes
                   are not processed.

            --ss     The input line is saved to the history.

            If the input is a terminal, both the --NN and --nn options set it into
            raw mode; they read an entire file if -1 is passed as _z argument.

            The first parameter may have a question mark and a string appended
            to it, in which case the string is used as a prompt (printed to
            standard error before any input is read) if the input is a tty(4)
            (e.g. rreeaadd nnffoooo??''nnuummbbeerr ooff ffooooss:: '').

            If no input is read or a timeout occurred, rreeaadd exits with a non-
            zero status.

            Another handy set of tricks: If rreeaadd is run in a loop such as
            wwhhiillee rreeaadd ffoooo;; ddoo ......;; ddoonnee then leading whitespace will be
            removed (IFS) and backslashes processed.  You might want to use
            wwhhiillee IIFFSS== rreeaadd --rr ffoooo;; ddoo ......;; ddoonnee for pristine I/O.  Similar-
            ily, when using the --aa option, use of the --rr option might be pru-
            dent; the same applies for:

                  find . -type f -print0 |& \
                      while IFS= read -d '' -pr filename; do
                          print -r -- "found <${filename#./}>"
                  done

            The inner loop will be executed in a subshell and variable changes
            cannot be propagated if executed in a pipeline:

                  bar | baz | while read foo; do ...; done

            Use co-processes instead:

                  bar | baz |&
                  while read -p foo; do ...; done
                  exec 3>&p; exec 3>&-

     rreeaaddoonnllyy [--pp] [_p_a_r_a_m_e_t_e_r [=_v_a_l_u_e] _._._.]
            Sets the read-only attribute of the named parameters.  If values
            are given, parameters are set to them before setting the
            attribute.  Once a parameter is made read-only, it cannot be unset
            and its value cannot be changed.

            If no parameters are specified, the names of all parameters with
            the read-only attribute are printed one per line, unless the --pp
            option is used, in which case rreeaaddoonnllyy commands defining all read-
            only parameters, including their values, are printed.

     rreeaallppaatthh [----] _n_a_m_e
            Prints the resolved absolute pathname corresponding to _n_a_m_e.  If
            _n_a_m_e ends with a slash ('/'), it's also checked for existence and
            whether it is a directory; otherwise, rreeaallppaatthh returns 0 if the
            pathname either exists or can be created immediately, i.e. all but
            the last component exist and are directories.

     rreennaammee [----] _f_r_o_m _t_o
            Renames the file _f_r_o_m to _t_o.  Both must be complete pathnames and
            on the same device.  This builtin is intended for emergency situa-
            tions where _/_b_i_n_/_m_v becomes unusable, and directly calls
            rename(2).

     rreettuurrnn [_s_t_a_t_u_s]
            Returns from a function or .. script, with exit status _s_t_a_t_u_s.  If
            no _s_t_a_t_u_s is given, the exit status of the last executed command
            is used.  If used outside of a function or .. script, it has the
            same effect as eexxiitt.  Note that mmkksshh treats both profile and ENV
            files as .. scripts, while the original Korn shell only treats pro-
            files as .. scripts.

     sseett [++--aabbCCeeffhhiikkllmmnnpprrssUUuuvvXXxx] [++--oo _o_p_t_i_o_n] [++--AA _n_a_m_e] [----] [_a_r_g _._._.]
            The sseett command can be used to set (--) or clear (++) shell options,
            set the positional parameters, or set an array parameter.  Options
            can be changed using the ++--oo _o_p_t_i_o_n syntax, where _o_p_t_i_o_n is the
            long name of an option, or using the ++--_l_e_t_t_e_r syntax, where _l_e_t_t_e_r
            is the option's single letter name (not all options have a single
            letter name).  The following table lists both option letters (if
            they exist) and long names along with a description of what the
            option does:

            --AA _n_a_m_e
                 Sets the elements of the array parameter _n_a_m_e to _a_r_g _._._. If
                 --AA is used, the array is reset (i.e. emptied) first; if ++AA is
                 used, the first N elements are set (where N is the number of
                 arguments); the rest are left untouched.

                 An alternative syntax for the command sseett --AA ffoooo ---- aa bb cc
                 which is compatible to GNU bbaasshh and also supported by AT&T
                 UNIX kksshh9933 is: ffoooo==((aa bb cc));; ffoooo++==((dd ee))

            --aa | --oo aalllleexxppoorrtt
                 All new parameters are created with the export attribute.

            --bb | --oo nnoottiiffyy
                 Print job notification messages asynchronously, instead of
                 just before the prompt.  Only used if job control is enabled
                 (--mm).

            --CC | --oo nnoocclloobbbbeerr
                 Prevent > redirection from overwriting existing files.
                 Instead, >| must be used to force an overwrite.  Note that
                 this is not safe to use for creation of temporary files or
                 lockfiles due to a TOCTOU in a check allowing one to redirect
                 output to _/_d_e_v_/_n_u_l_l or other device files even in nnoocclloobbbbeerr
                 mode.

            --ee | --oo eerrrreexxiitt
                 Exit (after executing the ERR trap) as soon as an error
                 occurs or a command fails (i.e. exits with a non-zero sta-
                 tus).  This does not apply to commands whose exit status is
                 explicitly tested by a shell construct such as iiff, uunnttiill,
                 wwhhiillee, or !! statements.  For &&&& or ||, only the status of the
                 last command is tested.

            --ff | --oo nnoogglloobb
                 Do not expand file name patterns.

            --hh | --oo ttrraacckkaallll
                 Create tracked aliases for all executed commands (see _A_l_i_a_s_e_s
                 above).  Enabled by default for non-interactive shells.

            --ii | --oo iinntteerraaccttiivvee
                 The shell is an interactive shell.  This option can only be
                 used when the shell is invoked.  See above for a description
                 of what this means.

            --kk | --oo kkeeyywwoorrdd
                 Parameter assignments are recognised anywhere in a command.

            --ll | --oo llooggiinn
                 The shell is a login shell.  This option can only be used
                 when the shell is invoked.  See above for a description of
                 what this means.

            --mm | --oo mmoonniittoorr
                 Enable job control (default for interactive shells).

            --nn | --oo nnooeexxeecc
                 Do not execute any commands.  Useful for checking the syntax
                 of scripts (ignored if interactive).

            --pp | --oo pprriivviilleeggeedd
                 The shell is a privileged shell.  It is set automatically if,
                 when the shell starts, the real UID or GID does not match the
                 effective UID (EUID) or GID (EGID), respectively.  See above
                 for a description of what this means.

            --rr | --oo rreessttrriicctteedd
                 The shell is a restricted shell.  This option can only be
                 used when the shell is invoked.  See above for a description
                 of what this means.

            --ss | --oo ssttddiinn
                 If used when the shell is invoked, commands are read from
                 standard input.  Set automatically if the shell is invoked
                 with no arguments.

                 When --ss is used with the sseett command it causes the specified
                 arguments to be sorted before assigning them to the posi-
                 tional parameters (or to array _n_a_m_e, if --AA is used).

            --UU | --oo uuttff88--mmooddee
                 Enable UTF-8 support in the _E_m_a_c_s _e_d_i_t_i_n_g _m_o_d_e and internal
                 string handling functions.  This flag is disabled by default,
                 but can be enabled by setting it on the shell command line;
                 is enabled automatically for interactive shells if requested
                 at compile time, your system supports sseettllooccaallee(_L_C___C_T_Y_P_E, _"_")
                 and optionally nnll__llaannggiinnffoo(_C_O_D_E_S_E_T), or the LC_ALL, LC_CTYPE,
                 or LANG environment variables, and at least one of these
                 returns something that matches "UTF-8" or "utf8" case-insen-
                 sitively; for direct builtin calls depending on the aforemen-
                 tioned environment variables; or for stdin or scripts, if the
                 input begins with a UTF-8 Byte Order Mark.

            --uu | --oo nnoouunnsseett
                 Referencing of an unset parameter, other than "$@" or "$*",
                 is treated as an error, unless one of the '-', '+', or '='
                 modifiers is used.

            --vv | --oo vveerrbboossee
                 Write shell input to standard error as it is read.

            --XX | --oo mmaarrkkddiirrss
                 Mark directories with a trailing '/' during file name genera-
                 tion.

            --xx | --oo xxttrraaccee
                 Print command trees when they are executed, preceded by the
                 value of PS4.

            --oo bbggnniiccee
                 Background jobs are run with lower priority.

            --oo bbrraacceeeexxppaanndd
                 Enable brace expansion (a.k.a. alternation).  This is enabled
                 by default.  If disabled, tilde expansion after an equals
                 sign is disabled as a side effect.

            --oo eemmaaccss
                 Enable BRL emacs-like command-line editing (interactive
                 shells only); see _E_m_a_c_s _e_d_i_t_i_n_g _m_o_d_e.

            --oo ggmmaaccss
                 Enable gmacs-like command-line editing (interactive shells
                 only).  Currently identical to emacs editing except that
                 transpose-chars (^T) acts slightly differently.

            --oo iiggnnoorreeeeooff
                 The shell will not (easily) exit when end-of-file is read;
                 eexxiitt must be used.  To avoid infinite loops, the shell will
                 exit if EOF is read 13 times in a row.

            --oo iinnhheerriitt--xxttrraaccee
                 Do not reset --oo xxttrraaccee upon entering functions.  This is
                 enabled by default.

            --oo nnoohhuupp
                 Do not kill running jobs with a SIGHUP signal when a login
                 shell exits.  Currently set by default, but this may change
                 in the future to be compatible with AT&T UNIX kksshh, which
                 doesn't have this option, but does send the SIGHUP signal.

            --oo nnoolloogg
                 No effect.  In the original Korn shell, this prevents func-
                 tion definitions from being stored in the history file.

            --oo pphhyyssiiccaall
                 Causes the ccdd and ppwwdd commands to use "physical" (i.e. the
                 filesystem's) '..' directories instead of "logical" directo-
                 ries (i.e. the shell handles '..', which allows the user to
                 be oblivious of symbolic links to directories).  Clear by
                 default.  Note that setting this option does not affect the
                 current value of the PWD parameter; only the ccdd command
                 changes PWD.  See the ccdd and ppwwdd commands above for more
                 details.

            --oo ppiippeeffaaiill
                 Make the exit status of a pipeline (before logically comple-
                 menting) the rightmost non-zero errorlevel, or zero if all
                 commands exited with zero.

            --oo ppoossiixx
                 Enable a somewhat more POSIXish mode.  As a side effect, set-
                 ting this flag turns off bbrraacceeeexxppaanndd mode, which can be
                 turned back on manually, and sshh mode.

            --oo sshh
                 Enable _/_b_i_n_/_s_h (kludge) mode.  Automatically enabled if the
                 basename of the shell invocation begins with "sh" and this
                 autodetection feature is compiled in (not in MirBSD).  As a
                 side effect, setting this flag turns off bbrraacceeeexxppaanndd mode,
                 which can be turned back on manually, and ppoossiixx mode.

            --oo vvii
                 Enable vi(1)-like command-line editing (interactive shells
                 only).  See _V_i _e_d_i_t_i_n_g _m_o_d_e for documentation and limita-
                 tions.

            --oo vvii--eessccccoommpplleettee
                 In vi command-line editing, do command and file name comple-
                 tion when escape (^[) is entered in command mode.

            --oo vvii--ttaabbccoommpplleettee
                 In vi command-line editing, do command and file name comple-
                 tion when tab (^I) is entered in insert mode.  This is the
                 default.

            --oo vviirraaww
                 No effect.  In the original Korn shell, unless vviirraaww was set,
                 the vi command-line mode would let the tty(4) driver do the
                 work until ESC (^[) was entered.  mmkksshh is always in viraw
                 mode.

            These options can also be used upon invocation of the shell.  The
            current set of options (with single letter names) can be found in
            the parameter '$-'.  sseett --oo with no option name will list all the
            options and whether each is on or off; sseett ++oo will print the long
            names of all options that are currently on.

            Remaining arguments, if any, are positional parameters and are
            assigned, in order, to the positional parameters (i.e. $1, $2,
            etc.).  If options end with '--' and there are no remaining argu-
            ments, all positional parameters are cleared.  If no options or
            arguments are given, the values of all names are printed.  For
            unknown historical reasons, a lone '-' option is treated specially
            - it clears both the --vv and --xx options.

     sshhiifftt [_n_u_m_b_e_r]
            The positional parameters _n_u_m_b_e_r+1, _n_u_m_b_e_r+2, etc. are renamed to
            '1', '2', etc.  _n_u_m_b_e_r defaults to 1.

     sslleeeepp _s_e_c_o_n_d_s
            Suspends execution for a minimum of the _s_e_c_o_n_d_s specified as posi-
            tive decimal value with an optional fractional part.  Signal
            delivery may continue execution earlier.

     ssoouurrccee _f_i_l_e [_a_r_g _._._.]
            Like .. ("dot"), except that the current working directory is
            appended to the PATH in GNU bbaasshh and mmkksshh.  In kksshh9933 and mmkksshh,
            this is implemented as a shell alias instead of a builtin.

     ssuussppeenndd
            Stops the shell as if it had received the suspend character from
            the terminal.  It is not possible to suspend a login shell unless
            the parent process is a member of the same terminal session but is
            a member of a different process group.  As a general rule, if the
            shell was started by another shell or via su(1), it can be sus-
            pended.

     tteesstt _e_x_p_r_e_s_s_i_o_n
     [[ _e_x_p_r_e_s_s_i_o_n ]]
            tteesstt evaluates the _e_x_p_r_e_s_s_i_o_n and returns zero status if true, 1
            if false, or greater than 1 if there was an error.  It is normally
            used as the condition command of iiff and wwhhiillee statements.  Sym-
            bolic links are followed for all _f_i_l_e expressions except --hh and
            --LL.

            The following basic expressions are available:

            --aa _f_i_l_e            _f_i_l_e exists.

            --bb _f_i_l_e            _f_i_l_e is a block special device.

            --cc _f_i_l_e            _f_i_l_e is a character special device.

            --dd _f_i_l_e            _f_i_l_e is a directory.

            --ee _f_i_l_e            _f_i_l_e exists.

            --ff _f_i_l_e            _f_i_l_e is a regular file.

            --GG _f_i_l_e            _f_i_l_e's group is the shell's effective group ID.

            --gg _f_i_l_e            _f_i_l_e's mode has the setgid bit set.

            --HH _f_i_l_e            _f_i_l_e is a context dependent directory (only
                               useful on HP-UX).

            --hh _f_i_l_e            _f_i_l_e is a symbolic link.

            --kk _f_i_l_e            _f_i_l_e's mode has the sticky(8) bit set.

            --LL _f_i_l_e            _f_i_l_e is a symbolic link.

            --OO _f_i_l_e            _f_i_l_e's owner is the shell's effective user ID.

            --oo _o_p_t_i_o_n          Shell _o_p_t_i_o_n is set (see the sseett command above
                               for a list of options).  As a non-standard
                               extension, if the option starts with a '!', the
                               test is negated; the test always fails if
                               _o_p_t_i_o_n doesn't exist (so [ -o foo -o -o !foo ]
                               returns true if and only if option _f_o_o exists).
                               The same can be achieved with [ -o ?foo ] like
                               in AT&T UNIX kksshh9933.  _o_p_t_i_o_n can also be the
                               short flag led by either '-' or '+' (no logical
                               negation), for example '-x' or '+x' instead of
                               'xtrace'.

            --pp _f_i_l_e            _f_i_l_e is a named pipe (FIFO).

            --rr _f_i_l_e            _f_i_l_e exists and is readable.

            --SS _f_i_l_e            _f_i_l_e is a unix(4)-domain socket.

            --ss _f_i_l_e            _f_i_l_e is not empty.

            --tt _f_d              File descriptor _f_d is a tty(4) device.

            --uu _f_i_l_e            _f_i_l_e's mode has the setuid bit set.

            --ww _f_i_l_e            _f_i_l_e exists and is writable.

            --xx _f_i_l_e            _f_i_l_e exists and is executable.

            _f_i_l_e_1 --nntt _f_i_l_e_2    _f_i_l_e_1 is newer than _f_i_l_e_2 or _f_i_l_e_1 exists and
                               _f_i_l_e_2 does not.

            _f_i_l_e_1 --oott _f_i_l_e_2    _f_i_l_e_1 is older than _f_i_l_e_2 or _f_i_l_e_2 exists and
                               _f_i_l_e_1 does not.

            _f_i_l_e_1 --eeff _f_i_l_e_2    _f_i_l_e_1 is the same file as _f_i_l_e_2.

            _s_t_r_i_n_g             _s_t_r_i_n_g has non-zero length.

            --nn _s_t_r_i_n_g          _s_t_r_i_n_g is not empty.

            --zz _s_t_r_i_n_g          _s_t_r_i_n_g is empty.

            _s_t_r_i_n_g = _s_t_r_i_n_g    Strings are equal.

            _s_t_r_i_n_g == _s_t_r_i_n_g   Strings are equal.

            _s_t_r_i_n_g > _s_t_r_i_n_g    First string operand is greater than second
                               string operand.

            _s_t_r_i_n_g < _s_t_r_i_n_g    First string operand is less than second string
                               operand.

            _s_t_r_i_n_g != _s_t_r_i_n_g   Strings are not equal.

            _n_u_m_b_e_r --eeqq _n_u_m_b_e_r  Numbers compare equal.

            _n_u_m_b_e_r --nnee _n_u_m_b_e_r  Numbers compare not equal.

            _n_u_m_b_e_r --ggee _n_u_m_b_e_r  Numbers compare greater than or equal.

            _n_u_m_b_e_r --ggtt _n_u_m_b_e_r  Numbers compare greater than.

            _n_u_m_b_e_r --llee _n_u_m_b_e_r  Numbers compare less than or equal.

            _n_u_m_b_e_r --lltt _n_u_m_b_e_r  Numbers compare less than.

            The above basic expressions, in which unary operators have prece-
            dence over binary operators, may be combined with the following
            operators (listed in increasing order of precedence):

                  expr -o expr            Logical OR.
                  expr -a expr            Logical AND.
                  ! expr                  Logical NOT.
                  ( expr )                Grouping.

            Note that a number actually may be an arithmetic expression, such
            as a mathematical term or the name of an integer variable:

                  x=1; [ "x" -eq 1 ]      evaluates to true

            Note that some special rules are applied (courtesy of POSIX) if
            the number of arguments to tteesstt or inside the brackets [[ ...... ]] is
            less than five: if leading '!' arguments can be stripped such that
            only one to three arguments remain, then the lowered comparison is
            executed; (thanks to XSI) parentheses \\(( ...... \\)) lower four- and
            three-argument forms to two- and one-argument forms, respectively;
            three-argument forms ultimately prefer binary operations, followed
            by negation and parenthesis lowering; two- and four-argument forms
            prefer negation followed by parenthesis; the one-argument form
            always implies --nn.

            NNoottee: A common mistake is to use "if [ $foo = bar ]" which fails
            if parameter "foo" is NULL or unset, if it has embedded spaces
            (i.e. IFS octets), or if it is a unary operator like '!' or '--nn'.
            Use tests like "if [ x"$foo" = x"bar" ]" instead, or the double-
            bracket operator "if [[ $foo = bar ]]" or, to avoid pattern match-
            ing (see [[[[ above): "if [[ $foo = "$bar" ]]"

            The [[[[ ...... ]]]] construct is not only more secure to use but also
            often faster.

     ttiimmee [--pp] [_p_i_p_e_l_i_n_e]
            If a _p_i_p_e_l_i_n_e is given, the times used to execute the pipeline are
            reported.  If no pipeline is given, then the user and system time
            used by the shell itself, and all the commands it has run since it
            was started, are reported.  The times reported are the real time
            (elapsed time from start to finish), the user CPU time (time spent
            running in user mode), and the system CPU time (time spent running
            in kernel mode).  Times are reported to standard error; the format
            of the output is:

                  0m0.00s real     0m0.00s user     0m0.00s system

            If the --pp option is given the output is slightly longer:

                  real     0.00
                  user     0.00
                  sys      0.00

            It is an error to specify the --pp option unless _p_i_p_e_l_i_n_e is a sim-
            ple command.

            Simple redirections of standard error do not affect the output of
            the ttiimmee command:

                  $ time sleep 1 2>afile
                  $ { time sleep 1; } 2>afile

            Times for the first command do not go to "afile", but those of the
            second command do.

     ttiimmeess  Print the accumulated user and system times used both by the shell
            and by processes that the shell started which have exited.  The
            format of the output is:

                  0m0.00s 0m0.00s
                  0m0.00s 0m0.00s

     ttrraapp _n [_s_i_g_n_a_l _._._.]
            If the first operand is a decimal unsigned integer, this resets
            all specified signals to the default action, i.e. is the same as
            calling ttrraapp with a minus sign ('-') as _h_a_n_d_l_e_r, followed by the
            arguments (_n [_s_i_g_n_a_l _._._.]), all of which are treated as signals.

     ttrraapp [_h_a_n_d_l_e_r _s_i_g_n_a_l _._._.]
            Sets a trap handler that is to be executed when any of the speci-
            fied _s_i_g_n_a_ls are received.  _h_a_n_d_l_e_r is either an empty string,
            indicating the signals are to be ignored, a minus sign ('-'),
            indicating that the default action is to be taken for the signals
            (see signal(3)), or a string containing shell commands to be exe-
            cuted at the first opportunity (i.e. when the current command com-
            pletes, or before printing the next PS1 prompt) after receipt of
            one of the signals.  _s_i_g_n_a_l is the name of a signal (e.g. PIPE or
            ALRM) or the number of the signal (see the kkiillll --ll command above).

            There are two special signals: EXIT (also known as 0), which is
            executed when the shell is about to exit, and ERR, which is exe-
            cuted after an error occurs; an error is something that would
            cause the shell to exit if the sseett --ee or sseett --oo eerrrreexxiitt option
            were set.  EXIT handlers are executed in the environment of the
            last executed command.

            Note that, for non-interactive shells, the trap handler cannot be
            changed for signals that were ignored when the shell started.

            With no arguments, the current state of the traps that have been
            set since the shell started is shown as a series of ttrraapp commands.
            Note that the output of ttrraapp cannot be usefully piped to another
            process (an artifact of the fact that traps are cleared when sub-
            processes are created).

            The original Korn shell's DEBUG trap and the handling of ERR and
            EXIT traps in functions are not yet implemented.

     ttrruuee   A command that exits with a zero value.

     gglloobbaall [[++--aallppnnrrttUUuuxx] [--LL[_n]] [--RR[_n]] [--ZZ[_n]] [--ii[_n]] | --ff [--ttuuxx]] [_n_a_m_e
            [=_v_a_l_u_e] _._._.]
     ttyyppeesseett [[++--aallppnnrrttUUuuxx] [--LLRRZZ[_n]] [--ii[_n]] | --ff [--ttuuxx]] [_n_a_m_e [=_v_a_l_u_e] _._._.]
            Display or set parameter attributes.  With no _n_a_m_e arguments,
            parameter attributes are displayed; if no options are used, the
            current attributes of all parameters are printed as ttyyppeesseett com-
            mands; if an option is given (or '-' with no option letter), all
            parameters and their values with the specified attributes are
            printed; if options are introduced with '+', parameter values are
            not printed.

            If _n_a_m_e arguments are given, the attributes of the named parame-
            ters are set (--) or cleared (++).  Values for parameters may
            optionally be specified.  For _n_a_m_e[*], the change affects the
            entire array, and no value may be specified.

            If ttyyppeesseett is used inside a function, any parameters specified are
            localised.  This is not done by the otherwise identical gglloobbaall.
            _N_o_t_e: This means that mmkksshh 's gglloobbaall command is _n_o_t equivalent to
            other programming languages' as it does not allow a function
            called from another function to access a parameter at truly global
            scope, but only prevents putting an accessed one into local scope.

            When --ff is used, ttyyppeesseett operates on the attributes of functions.
            As with parameters, if no _n_a_m_e arguments are given, functions are
            listed with their values (i.e. definitions) unless options are
            introduced with '+', in which case only the function names are
            reported.

            --aa      Indexed array attribute.

            --ff      Function mode.  Display or set functions and their
                    attributes, instead of parameters.

            --ii[_n]   Integer attribute.  _n specifies the base to use when dis-
                    playing the integer (if not specified, the base given in
                    the first assignment is used).  Parameters with this
                    attribute may be assigned values containing arithmetic
                    expressions.

            --LL[_n]   Left justify attribute.  _n specifies the field width.  If
                    _n is not specified, the current width of a parameter (or
                    the width of its first assigned value) is used.  Leading
                    whitespace (and zeros, if used with the --ZZ option) is
                    stripped.  If necessary, values are either truncated or
                    space padded to fit the field width.

            --ll      Lower case attribute.  All upper case characters in values
                    are converted to lower case.  (In the original Korn shell,
                    this parameter meant "long integer" when used with the --ii
                    option.)

            --nn      Create a bound variable (name reference): any access to
                    the variable _n_a_m_e will access the variable _v_a_l_u_e in the
                    current scope (this is different from AT&T UNIX kksshh9933!)
                    instead.  Also different from AT&T UNIX kksshh9933 is that
                    _v_a_l_u_e is lazily evaluated at the time _n_a_m_e is accessed.
                    This can be used by functions to access variables whose
                    names are passed as parametres, instead of using eevvaall.

            --pp      Print complete ttyyppeesseett commands that can be used to re-
                    create the attributes and values of parameters.

            --RR[_n]   Right justify attribute.  _n specifies the field width.  If
                    _n is not specified, the current width of a parameter (or
                    the width of its first assigned value) is used.  Trailing
                    whitespace is stripped.  If necessary, values are either
                    stripped of leading characters or space padded to make
                    them fit the field width.

            --rr      Read-only attribute.  Parameters with this attribute may
                    not be assigned to or unset.  Once this attribute is set,
                    it cannot be turned off.

            --tt      Tag attribute.  Has no meaning to the shell; provided for
                    application use.

                    For functions, --tt is the trace attribute.  When functions
                    with the trace attribute are executed, the xxttrraaccee (--xx)
                    shell option is temporarily turned on.

            --UU      Unsigned integer attribute.  Integers are printed as
                    unsigned values (combine with the --ii option).  This option
                    is not in the original Korn shell.

            --uu      Upper case attribute.  All lower case characters in values
                    are converted to upper case.  (In the original Korn shell,
                    this parameter meant "unsigned integer" when used with the
                    --ii option which meant upper case letters would never be
                    used for bases greater than 10.  See the --UU option.)

                    For functions, --uu is the undefined attribute.  See
                    _F_u_n_c_t_i_o_n_s above for the implications of this.

            --xx      Export attribute.  Parameters (or functions) are placed in
                    the environment of any executed commands.  Exported func-
                    tions are not yet implemented.

            --ZZ[_n]   Zero fill attribute.  If not combined with --LL, this is the
                    same as --RR, except zero padding is used instead of space
                    padding.  For integers, the number instead of the base is
                    padded.

            If any of the --ii, --LL, --ll, --RR, --UU, --uu, or --ZZ options are changed,
            all others from this set are cleared, unless they are also given
            on the same command line.

     uulliimmiitt [--aaBBCCccddeeffHHiillMMmmnnOOPPppqqrrSSssTTttVVvvww] [_v_a_l_u_e]
            Display or set process limits.  If no options are used, the file
            size limit (--ff) is assumed.  _v_a_l_u_e, if specified, may be either an
            arithmetic expression or the word "unlimited".  The limits affect
            the shell and any processes created by the shell after a limit is
            imposed.  Note that some systems may not allow limits to be
            increased once they are set.  Also note that the types of limits
            available are system dependent - some systems have only the --ff
            limit.

            --aa     Display all limits; unless --HH is used, soft limits are dis-
                   played.

            --BB _n   Set the socket buffer size to _n kibibytes.

            --CC _n   Set the number of cached threads to _n.

            --cc _n   Impose a size limit of _n blocks on the size of core dumps.

            --dd _n   Impose a size limit of _n kibibytes on the size of the data
                   area.

            --ee _n   Set the maximum niceness to _n.

            --ff _n   Impose a size limit of _n blocks on files written by the
                   shell and its child processes (files of any size may be
                   read).

            --HH     Set the hard limit only (the default is to set both hard
                   and soft limits).

            --ii _n   Set the number of pending signals to _n.

            --ll _n   Impose a limit of _n kibibytes on the amount of locked
                   (wired) physical memory.

            --MM _n   Set the AIO locked memory to _n kibibytes.

            --mm _n   Impose a limit of _n kibibytes on the amount of physical
                   memory used.

            --nn _n   Impose a limit of _n file descriptors that can be open at
                   once.

            --OO _n   Set the number of AIO operations to _n.

            --PP _n   Limit the number of threads per process to _n.

            --pp _n   Impose a limit of _n processes that can be run by the user
                   at any one time.

            --qq _n   Limit the size of POSIX message queues to _n bytes.

            --rr _n   Set the maximum real-time priority to _n.

            --SS     Set the soft limit only (the default is to set both hard
                   and soft limits).

            --ss _n   Impose a size limit of _n kibibytes on the size of the stack
                   area.

            --TT _n   Impose a time limit of _n real seconds to be used by each
                   process.

            --tt _n   Impose a time limit of _n CPU seconds spent in user mode to
                   be used by each process.

            --VV _n   Set the number of vnode monitors on Haiku to _n.

            --vv _n   Impose a limit of _n kibibytes on the amount of virtual mem-
                   ory (address space) used.

            --ww _n   Impose a limit of _n kibibytes on the amount of swap space
                   used.

            As far as uulliimmiitt is concerned, a block is 512 bytes.

     uummaasskk [--SS] [_m_a_s_k]
            Display or set the file permission creation mask, or umask (see
            umask(2)).  If the --SS option is used, the mask displayed or set is
            symbolic; otherwise, it is an octal number.

            Symbolic masks are like those used by chmod(1).  When used, they
            describe what permissions may be made available (as opposed to
            octal masks in which a set bit means the corresponding bit is to
            be cleared).  For example, "ug=rwx,o=" sets the mask so files will
            not be readable, writable, or executable by "others", and is
            equivalent (on most systems) to the octal mask "007".

     uunnaalliiaass [--aaddtt] [_n_a_m_e _._._.]
            The aliases for the given names are removed.  If the --aa option is
            used, all aliases are removed.  If the --tt or --dd options are used,
            the indicated operations are carried out on tracked or directory
            aliases, respectively.

     uunnsseett [--ffvv] _p_a_r_a_m_e_t_e_r _._._.
            Unset the named parameters (--vv, the default) or functions (--ff).
            With _p_a_r_a_m_e_t_e_r[*], attributes are kept, only values are unset.

            The exit status is non-zero if any of the parameters have the
            read-only attribute set, zero otherwise.

     wwaaiitt [_j_o_b _._._.]
            Wait for the specified job(s) to finish.  The exit status of wwaaiitt
            is that of the last specified job; if the last job is killed by a
            signal, the exit status is 128 + the number of the signal (see
            kkiillll --ll _e_x_i_t_-_s_t_a_t_u_s above); if the last specified job can't be
            found (because it never existed, or had already finished), the
            exit status of wwaaiitt is 127.  See _J_o_b _c_o_n_t_r_o_l below for the format
            of _j_o_b.  wwaaiitt will return if a signal for which a trap has been
            set is received, or if a SIGHUP, SIGINT, or SIGQUIT signal is
            received.

            If no jobs are specified, wwaaiitt waits for all currently running
            jobs (if any) to finish and exits with a zero status.  If job mon-
            itoring is enabled, the completion status of jobs is printed (this
            is not the case when jobs are explicitly specified).

     wwhheennccee [--ppvv] [_n_a_m_e _._._.]
            For each _n_a_m_e, the type of command is listed (reserved word,
            built-in, alias, function, tracked alias, or executable).  If the
            --pp option is used, a path search is performed even if _n_a_m_e is a
            reserved word, alias, etc.  Without the --vv option, wwhheennccee is simi-
            lar to ccoommmmaanndd --vv except that wwhheennccee will find reserved words and
            won't print aliases as alias commands.  With the --vv option, wwhheennccee
            is the same as ccoommmmaanndd --VV.  Note that for wwhheennccee, the --pp option
            does not affect the search path used, as it does for ccoommmmaanndd.  If
            the type of one or more of the names could not be determined, the
            exit status is non-zero.

   JJoobb ccoonnttrrooll
     Job control refers to the shell's ability to monitor and control jobs
     which are processes or groups of processes created for commands or pipe-
     lines.  At a minimum, the shell keeps track of the status of the back-
     ground (i.e. asynchronous) jobs that currently exist; this information
     can be displayed using the jjoobbss commands.  If job control is fully
     enabled (using sseett --mm or sseett --oo mmoonniittoorr), as it is for interactive
     shells, the processes of a job are placed in their own process group.
     Foreground jobs can be stopped by typing the suspend character from the
     terminal (normally ^Z), jobs can be restarted in either the foreground or
     background using the ffgg and bbgg commands, and the state of the terminal is
     saved or restored when a foreground job is stopped or restarted, respec-
     tively.

     Note that only commands that create processes (e.g. asynchronous com-
     mands, subshell commands, and non-built-in, non-function commands) can be
     stopped; commands like rreeaadd cannot be.

     When a job is created, it is assigned a job number.  For interactive
     shells, this number is printed inside "[..]", followed by the process IDs
     of the processes in the job when an asynchronous command is run.  A job
     may be referred to in the bbgg, ffgg, jjoobbss, kkiillll, and wwaaiitt commands either by
     the process ID of the last process in the command pipeline (as stored in
     the $$!! parameter) or by prefixing the job number with a percent sign
     ('%').  Other percent sequences can also be used to refer to jobs:

     %+ | %% | %    The most recently stopped job, or, if there are no stopped
                    jobs, the oldest running job.

     %-             The job that would be the %%++ job if the latter did not
                    exist.

     %_n             The job with job number _n.

     %?_s_t_r_i_n_g       The job with its command containing the string _s_t_r_i_n_g (an
                    error occurs if multiple jobs are matched).

     %_s_t_r_i_n_g        The job with its command starting with the string _s_t_r_i_n_g
                    (an error occurs if multiple jobs are matched).

     When a job changes state (e.g. a background job finishes or foreground
     job is stopped), the shell prints the following status information:

           [_n_u_m_b_e_r] _f_l_a_g _s_t_a_t_u_s _c_o_m_m_a_n_d

     where...

     _n_u_m_b_e_r   is the job number of the job;

     _f_l_a_g     is the '+' or '-' character if the job is the %%++ or %%-- job,
              respectively, or space if it is neither;

     _s_t_a_t_u_s   indicates the current state of the job and can be:

              Done [_n_u_m_b_e_r]
                         The job exited.  _n_u_m_b_e_r is the exit status of the job
                         which is omitted if the status is zero.

              Running    The job has neither stopped nor exited (note that
                         running does not necessarily mean consuming CPU time
                         - the process could be blocked waiting for some
                         event).

              Stopped [_s_i_g_n_a_l]
                         The job was stopped by the indicated _s_i_g_n_a_l (if no
                         signal is given, the job was stopped by SIGTSTP).

              _s_i_g_n_a_l_-_d_e_s_c_r_i_p_t_i_o_n ["core dumped"]
                         The job was killed by a signal (e.g. memory fault,
                         hangup); use kkiillll --ll for a list of signal descrip-
                         tions.  The "core dumped" message indicates the
                         process created a core file.

     _c_o_m_m_a_n_d  is the command that created the process.  If there are multiple
              processes in the job, each process will have a line showing its
              _c_o_m_m_a_n_d and possibly its _s_t_a_t_u_s, if it is different from the
              status of the previous process.

     When an attempt is made to exit the shell while there are jobs in the
     stopped state, the shell warns the user that there are stopped jobs and
     does not exit.  If another attempt is immediately made to exit the shell,
     the stopped jobs are sent a SIGHUP signal and the shell exits.  Simi-
     larly, if the nnoohhuupp option is not set and there are running jobs when an
     attempt is made to exit a login shell, the shell warns the user and does
     not exit.  If another attempt is immediately made to exit the shell, the
     running jobs are sent a SIGHUP signal and the shell exits.

   IInntteerraaccttiivvee iinnppuutt lliinnee eeddiittiinngg
     The shell supports three modes of reading command lines from a tty(4) in
     an interactive session, controlled by the eemmaaccss, ggmmaaccss, and vvii options
     (at most one of these can be set at once).  The default is eemmaaccss.  Edit-
     ing modes can be set explicitly using the sseett built-in.  If none of these
     options are enabled, the shell simply reads lines using the normal tty(4)
     driver.  If the eemmaaccss or ggmmaaccss option is set, the shell allows emacs-like
     editing of the command; similarly, if the vvii option is set, the shell
     allows vi-like editing of the command.  These modes are described in
     detail in the following sections.

     In these editing modes, if a line is longer than the screen width (see
     the COLUMNS parameter), a '>', '+', or '<' character is displayed in the
     last column indicating that there are more characters after, before and
     after, or before the current position, respectively.  The line is
     scrolled horizontally as necessary.

     Completed lines are pushed into the history, unless they begin with an
     IFS octet or IFS white space, or are the same as the previous line.

   EEmmaaccss eeddiittiinngg mmooddee
     When the eemmaaccss option is set, interactive input line editing is enabled.
     Warning: This mode is slightly different from the emacs mode in the orig-
     inal Korn shell.  In this mode, various editing commands (typically bound
     to one or more control characters) cause immediate actions without wait-
     ing for a newline.  Several editing commands are bound to particular con-
     trol characters when the shell is invoked; these bindings can be changed
     using the bbiinndd command.

     The following is a list of available editing commands.  Each description
     starts with the name of the command, suffixed with a colon; an [_n] (if
     the command can be prefixed with a count); and any keys the command is
     bound to by default, written using caret notation e.g. the ASCII ESC
     character is written as ^[.  These control sequences are not case sensi-
     tive.  A count prefix for a command is entered using the sequence ^[_n,
     where _n is a sequence of 1 or more digits.  Unless otherwise specified,
     if a count is omitted, it defaults to 1.

     Note that editing command names are used only with the bbiinndd command.
     Furthermore, many editing commands are useful only on terminals with a
     visible cursor.  The default bindings were chosen to resemble correspond-
     ing Emacs key bindings.  The user's tty(4) characters (e.g. ERASE) are
     bound to reasonable substitutes and override the default bindings.

     abort: ^C, ^G
             Abort the current command, empty the line buffer and set the exit
             state to interrupted.

     auto-insert: [_n]
             Simply causes the character to appear as literal input.  Most
             ordinary characters are bound to this.

     backward-char: [_n] ^B, ^XD, ANSI-CurLeft, PC-CurLeft
             Moves the cursor backward _n characters.

     backward-word: [_n] ^[b, ANSI-Ctrl-CurLeft, ANSI-Alt-CurLeft
             Moves the cursor backward to the beginning of the word; words
             consist of alphanumerics, underscore ('_'), and dollar sign ('$')
             characters.

     beginning-of-history: ^[<
             Moves to the beginning of the history.

     beginning-of-line: ^A, ANSI-Home, PC-Home
             Moves the cursor to the beginning of the edited input line.

     capitalise-word: [_n] ^[C, ^[c
             Uppercase the first character in the next _n words, leaving the
             cursor past the end of the last word.

     clear-screen: ^[^L
             Prints a compile-time configurable sequence to clear the screen
             and home the cursor, redraws the entire prompt and the currently
             edited input line.  The default sequence works for almost all
             standard terminals.

     comment: ^[#
             If the current line does not begin with a comment character, one
             is added at the beginning of the line and the line is entered (as
             if return had been pressed); otherwise, the existing comment
             characters are removed and the cursor is placed at the beginning
             of the line.

     complete: ^[^[
             Automatically completes as much as is unique of the command name
             or the file name containing the cursor.  If the entire remaining
             command or file name is unique, a space is printed after its com-
             pletion, unless it is a directory name in which case '/' is
             appended.  If there is no command or file name with the current
             partial word as its prefix, a bell character is output (usually
             causing a beep to be sounded).

     complete-command: ^X^[
             Automatically completes as much as is unique of the command name
             having the partial word up to the cursor as its prefix, as in the
             ccoommpplleettee command above.

     complete-file: ^[^X
             Automatically completes as much as is unique of the file name
             having the partial word up to the cursor as its prefix, as in the
             ccoommpplleettee command described above.

     complete-list: ^I, ^[=
             Complete as much as is possible of the current word, and list the
             possible completions for it.  If only one completion is possible,
             match as in the ccoommpplleettee command above.  Note that ^I is usually
             generated by the TAB (tabulator) key.

     delete-char-backward: [_n] ERASE, ^?, ^H
             Deletes _n characters before the cursor.

     delete-char-forward: [_n] ANSI-Del, PC-Del
             Deletes _n characters after the cursor.

     delete-word-backward: [_n] WERASE, ^[^?, ^[^H, ^[h
             Deletes _n words before the cursor.

     delete-word-forward: [_n] ^[d
             Deletes characters after the cursor up to the end of _n words.

     down-history: [_n] ^N, ^XB, ANSI-CurDown, PC-CurDown
             Scrolls the history buffer forward _n lines (later).  Each input
             line originally starts just after the last entry in the history
             buffer, so ddoowwnn--hhiissttoorryy is not useful until either
             sseeaarrcchh--hhiissttoorryy, sseeaarrcchh--hhiissttoorryy--uupp or uupp--hhiissttoorryy has been per-
             formed.

     downcase-word: [_n] ^[L, ^[l
             Lowercases the next _n words.

     edit-line: [_n] ^Xe
             Edit line _n or the current line, if not specified, interactively.
             The actual command executed is ffcc --ee $${{VVIISSUUAALL::--$${{EEDDIITTOORR::--vvii}}}} _n.

     end-of-history: ^[>
             Moves to the end of the history.

     end-of-line: ^E, ANSI-End, PC-End
             Moves the cursor to the end of the input line.

     eot: ^_
             Acts as an end-of-file; this is useful because edit-mode input
             disables normal terminal input canonicalization.

     eot-or-delete: [_n] ^D
             Acts as eeoott if alone on a line; otherwise acts as
             ddeelleettee--cchhaarr--ffoorrwwaarrdd.

     error: (not bound)
             Error (ring the bell).

     exchange-point-and-mark: ^X^X
             Places the cursor where the mark is and sets the mark to where
             the cursor was.

     expand-file: ^[*
             Appends a '*' to the current word and replaces the word with the
             result of performing file globbing on the word.  If no files
             match the pattern, the bell is rung.

     forward-char: [_n] ^F, ^XC, ANSI-CurRight, PC-CurRight
             Moves the cursor forward _n characters.

     forward-word: [_n] ^[f, ANSI-Ctrl-CurRight, ANSI-Alt-CurRight
             Moves the cursor forward to the end of the _nth word.

     goto-history: [_n] ^[g
             Goes to history number _n.

     kill-line: KILL
             Deletes the entire input line.

     kill-region: ^W
             Deletes the input between the cursor and the mark.

     kill-to-eol: [_n] ^K
             Deletes the input from the cursor to the end of the line if _n is
             not specified; otherwise deletes characters between the cursor
             and column _n.

     list: ^[?
             Prints a sorted, columnated list of command names or file names
             (if any) that can complete the partial word containing the cur-
             sor.  Directory names have '/' appended to them.

     list-command: ^X?
             Prints a sorted, columnated list of command names (if any) that
             can complete the partial word containing the cursor.

     list-file: ^X^Y
             Prints a sorted, columnated list of file names (if any) that can
             complete the partial word containing the cursor.  File type indi-
             cators are appended as described under lliisstt above.

     newline: ^J, ^M
             Causes the current input line to be processed by the shell.  The
             current cursor position may be anywhere on the line.

     newline-and-next: ^O
             Causes the current input line to be processed by the shell, and
             the next line from history becomes the current line.  This is
             only useful after an uupp--hhiissttoorryy, sseeaarrcchh--hhiissttoorryy or
             sseeaarrcchh--hhiissttoorryy--uupp.

     no-op: QUIT
             This does nothing.

     prefix-1: ^[
             Introduces a 2-character command sequence.

     prefix-2: ^X, ^[[, ^[O
             Introduces a 2-character command sequence.

     prev-hist-word: [_n] ^[., ^[_
             The last word, or, if given, the _nth word (zero-based) of the
             previous (on repeated execution, second-last, third-last, etc.)
             command is inserted at the cursor.  Use of this editing command
             trashes the mark.

     quote: ^^, ^V
             The following character is taken literally rather than as an
             editing command.

     redraw: ^L
             Reprints the last line of the prompt string and the current input
             line on a new line.

     search-character-backward: [_n] ^[^]
             Search backward in the current line for the _nth occurrence of the
             next character typed.

     search-character-forward: [_n] ^]
             Search forward in the current line for the _nth occurrence of the
             next character typed.

     search-history: ^R
             Enter incremental search mode.  The internal history list is
             searched backwards for commands matching the input.  An initial
             '^' in the search string anchors the search.  The escape key will
             leave search mode.  Other commands, including sequences of escape
             as pprreeffiixx--11 followed by a pprreeffiixx--11 or pprreeffiixx--22 key will be exe-
             cuted after leaving search mode.  The aabboorrtt (^G) command will
             restore the input line before search started.  Successive
             sseeaarrcchh--hhiissttoorryy commands continue searching backward to the next
             previous occurrence of the pattern.  The history buffer retains
             only a finite number of lines; the oldest are discarded as neces-
             sary.

     search-history-up: ANSI-PgUp, PC-PgUp
             Search backwards through the history buffer for commands whose
             beginning match the portion of the input line before the cursor.
             When used on an empty line, this has the same effect as
             uupp--hhiissttoorryy.

     search-history-down: ANSI-PgDn, PC-PgDn
             Search forwards through the history buffer for commands whose
             beginning match the portion of the input line before the cursor.
             When used on an empty line, this has the same effect as
             ddoowwnn--hhiissttoorryy.  This is only useful after an uupp--hhiissttoorryy,
             sseeaarrcchh--hhiissttoorryy or sseeaarrcchh--hhiissttoorryy--uupp.

     set-mark-command: ^[<space>
             Set the mark at the cursor position.

     transpose-chars: ^T
             If at the end of line, or if the ggmmaaccss option is set, this
             exchanges the two previous characters; otherwise, it exchanges
             the previous and current characters and moves the cursor one
             character to the right.

     up-history: [_n] ^P, ^XA, ANSI-CurUp, PC-CurUp
             Scrolls the history buffer backward _n lines (earlier).

     upcase-word: [_n] ^[U, ^[u
             Uppercase the next _n words.

     version: ^[^V
             Display the version of mmkksshh.  The current edit buffer is restored
             as soon as a key is pressed.  The restoring keypress is pro-
             cessed, unless it is a space.

     yank: ^Y
             Inserts the most recently killed text string at the current cur-
             sor position.

     yank-pop: ^[y
             Immediately after a yyaannkk, replaces the inserted text string with
             the next previously killed text string.

   VVii eeddiittiinngg mmooddee
     _N_o_t_e_: The vi command-line editing mode is orphaned, yet still functional.
     It is 8-bit clean but specifically does not support UTF-8 or MBCS.

     The vi command-line editor in mmkksshh has basically the same commands as the
     vi(1) editor with the following exceptions:

     ++oo   You start out in insert mode.

     ++oo   There are file name and command completion commands: =, \, *, ^X, ^E,
         ^F, and, optionally, <tab> and <esc>.

     ++oo   The __ command is different (in mmkksshh, it is the last argument command;
         in vi(1) it goes to the start of the current line).

     ++oo   The // and GG commands move in the opposite direction to the jj command.

     ++oo   Commands which don't make sense in a single line editor are not
         available (e.g. screen movement commands and ex(1)-style colon (::)
         commands).

     Like vi(1), there are two modes: "insert" mode and "command" mode.  In
     insert mode, most characters are simply put in the buffer at the current
     cursor position as they are typed; however, some characters are treated
     specially.  In particular, the following characters are taken from cur-
     rent tty(4) settings (see stty(1)) and have their usual meaning (normal
     values are in parentheses): kill (^U), erase (^?), werase (^W), eof (^D),
     intr (^C), and quit (^\).  In addition to the above, the following char-
     acters are also treated specially in insert mode:

     ^E       Command and file name enumeration (see below).

     ^F       Command and file name completion (see below).  If used twice in
              a row, the list of possible completions is displayed; if used a
              third time, the completion is undone.

     ^H       Erases previous character.

     ^J | ^M  End of line.  The current line is read, parsed, and executed by
              the shell.

     ^V       Literal next.  The next character typed is not treated specially
              (can be used to insert the characters being described here).

     ^X       Command and file name expansion (see below).

     <esc>    Puts the editor in command mode (see below).

     <tab>    Optional file name and command completion (see ^^FF above),
              enabled with sseett --oo vvii--ttaabbccoommpplleettee.

     In command mode, each character is interpreted as a command.  Characters
     that don't correspond to commands, are illegal combinations of commands,
     or are commands that can't be carried out, all cause beeps.  In the fol-
     lowing command descriptions, an [_n] indicates the command may be prefixed
     by a number (e.g. 1100ll moves right 10 characters); if no number prefix is
     used, _n is assumed to be 1 unless otherwise specified.  The term "current
     position" refers to the position between the cursor and the character
     preceding the cursor.  A "word" is a sequence of letters, digits, and
     underscore characters or a sequence of non-letter, non-digit, non-under-
     score, and non-whitespace characters (e.g. "ab2*&^" contains two words)
     and a "big-word" is a sequence of non-whitespace characters.

     Special mmkksshh vi commands:

     The following commands are not in, or are different from, the normal vi
     file editor:

     [_n]_        Insert a space followed by the _nth big-word from the last
                 command in the history at the current position and enter
                 insert mode; if _n is not specified, the last word is
                 inserted.

     #           Insert the comment character ('#') at the start of the cur-
                 rent line and return the line to the shell (equivalent to
                 II##^^JJ).

     [_n]g        Like GG, except if _n is not specified, it goes to the most
                 recent remembered line.

     [_n]v        Edit line _n using the vi(1) editor; if _n is not specified,
                 the current line is edited.  The actual command executed is
                 ffcc --ee $${{VVIISSUUAALL::--$${{EEDDIITTOORR::--vvii}}}} _n.

     * and ^X    Command or file name expansion is applied to the current big-
                 word (with an appended '*' if the word contains no file glob-
                 bing characters) - the big-word is replaced with the result-
                 ing words.  If the current big-word is the first on the line
                 or follows one of the characters ';', '|', '&', '(', or ')',
                 and does not contain a slash ('/'), then command expansion is
                 done; otherwise file name expansion is done.  Command expan-
                 sion will match the big-word against all aliases, functions,
                 and built-in commands as well as any executable files found
                 by searching the directories in the PATH parameter.  File
                 name expansion matches the big-word against the files in the
                 current directory.  After expansion, the cursor is placed
                 just past the last word and the editor is in insert mode.

     [_n]\, [_n]^F, [_n]<tab>, and [_n]<esc>
                 Command/file name completion.  Replace the current big-word
                 with the longest unique match obtained after performing com-
                 mand and file name expansion.  <tab> is only recognised if
                 the vvii--ttaabbccoommpplleettee option is set, while <esc> is only recog-
                 nised if the vvii--eessccccoommpplleettee option is set (see sseett --oo).  If _n
                 is specified, the _nth possible completion is selected (as
                 reported by the command/file name enumeration command).

     = and ^E    Command/file name enumeration.  List all the commands or
                 files that match the current big-word.

     ^V          Display the version of mmkksshh.  The current edit buffer is
                 restored as soon as a key is pressed.  The restoring keypress
                 is ignored.

     @_c          Macro expansion.  Execute the commands found in the alias _c.

     Intra-line movement commands:

     [_n]h and [_n]^H
             Move left _n characters.

     [_n]l and [_n]<space>
             Move right _n characters.

     0       Move to column 0.

     ^       Move to the first non-whitespace character.

     [_n]|    Move to column _n.

     $       Move to the last character.

     [_n]b    Move back _n words.

     [_n]B    Move back _n big-words.

     [_n]e    Move forward to the end of the word, _n times.

     [_n]E    Move forward to the end of the big-word, _n times.

     [_n]w    Move forward _n words.

     [_n]W    Move forward _n big-words.

     %       Find match.  The editor looks forward for the nearest parenthe-
             sis, bracket, or brace and then moves the cursor to the matching
             parenthesis, bracket, or brace.

     [_n]f_c   Move forward to the _nth occurrence of the character _c.

     [_n]F_c   Move backward to the _nth occurrence of the character _c.

     [_n]t_c   Move forward to just before the _nth occurrence of the character
             _c.

     [_n]T_c   Move backward to just before the _nth occurrence of the character
             _c.

     [_n];    Repeats the last ff, FF, tt, or TT command.

     [_n],    Repeats the last ff, FF, tt, or TT command, but moves in the opposite
             direction.

     Inter-line movement commands:

     [_n]j, [_n]+, and [_n]^N
             Move to the _nth next line in the history.

     [_n]k, [_n]-, and [_n]^P
             Move to the _nth previous line in the history.

     [_n]G    Move to line _n in the history; if _n is not specified, the number
             of the first remembered line is used.

     [_n]g    Like GG, except if _n is not specified, it goes to the most recent
             remembered line.

     [_n]/_s_t_r_i_n_g
             Search backward through the history for the _nth line containing
             _s_t_r_i_n_g; if _s_t_r_i_n_g starts with '^', the remainder of the string
             must appear at the start of the history line for it to match.

     [_n]?_s_t_r_i_n_g
             Same as //, except it searches forward through the history.

     [_n]n    Search for the _nth occurrence of the last search string; the
             direction of the search is the same as the last search.

     [_n]N    Search for the _nth occurrence of the last search string; the
             direction of the search is the opposite of the last search.

     _A_N_S_I_-_C_u_r_U_p, _P_C_-_P_g_U_p
             Take the characters from the beginning of the line to the current
             cursor position as search string and do a backwards history
             search for lines beginning with this string; keep the cursor
             position.  This works only in insert mode and keeps it enabled.

     Edit commands

     [_n]a    Append text _n times; goes into insert mode just after the current
             position.  The append is only replicated if command mode is re-
             entered i.e. <esc> is used.

     [_n]A    Same as aa, except it appends at the end of the line.

     [_n]i    Insert text _n times; goes into insert mode at the current posi-
             tion.  The insertion is only replicated if command mode is re-
             entered i.e. <esc> is used.

     [_n]I    Same as ii, except the insertion is done just before the first
             non-blank character.

     [_n]s    Substitute the next _n characters (i.e. delete the characters and
             go into insert mode).

     S       Substitute whole line.  All characters from the first non-blank
             character to the end of the line are deleted and insert mode is
             entered.

     [_n]c_m_o_v_e_-_c_m_d
             Change from the current position to the position resulting from _n
             _m_o_v_e_-_c_m_ds (i.e. delete the indicated region and go into insert
             mode); if _m_o_v_e_-_c_m_d is cc, the line starting from the first non-
             blank character is changed.

     C       Change from the current position to the end of the line (i.e.
             delete to the end of the line and go into insert mode).

     [_n]x    Delete the next _n characters.

     [_n]X    Delete the previous _n characters.

     D       Delete to the end of the line.

     [_n]d_m_o_v_e_-_c_m_d
             Delete from the current position to the position resulting from _n
             _m_o_v_e_-_c_m_ds; _m_o_v_e_-_c_m_d is a movement command (see above) or dd, in
             which case the current line is deleted.

     [_n]r_c   Replace the next _n characters with the character _c.

     [_n]R    Replace.  Enter insert mode but overwrite existing characters
             instead of inserting before existing characters.  The replacement
             is repeated _n times.

     [_n]~    Change the case of the next _n characters.

     [_n]y_m_o_v_e_-_c_m_d
             Yank from the current position to the position resulting from _n
             _m_o_v_e_-_c_m_ds into the yank buffer; if _m_o_v_e_-_c_m_d is yy, the whole line
             is yanked.

     Y       Yank from the current position to the end of the line.

     [_n]p    Paste the contents of the yank buffer just after the current
             position, _n times.

     [_n]P    Same as pp, except the buffer is pasted at the current position.

     Miscellaneous vi commands

     ^J and ^M
             The current line is read, parsed, and executed by the shell.

     ^L and ^R
             Redraw the current line.

     [_n].    Redo the last edit command _n times.

     u       Undo the last edit command.

     U       Undo all changes that have been made to the current line.

     PC Home, End, Del, and cursor keys
             They move as expected, both in insert and command mode.

     _i_n_t_r and _q_u_i_t
             The interrupt and quit terminal characters cause the current line
             to be deleted and a new prompt to be printed.

FFIILLEESS
     ~/.mkshrc          User mkshrc profile (non-privileged interactive
                        shells); see _S_t_a_r_t_u_p _f_i_l_e_s_. The location can be
                        changed at compile time (for embedded systems); AOSP
                        Android builds use _/_s_y_s_t_e_m_/_e_t_c_/_m_k_s_h_r_c.
     ~/.profile         User profile (non-privileged login shells); see
                        _S_t_a_r_t_u_p _f_i_l_e_s near the top of this manual.
     /etc/profile       System profile (login shells); see _S_t_a_r_t_u_p _f_i_l_e_s_.
     /etc/shells        Shell database.
     /etc/suid_profile  Suid profile (privileged shells); see _S_t_a_r_t_u_p _f_i_l_e_s_.

     Note: On Android, _/_s_y_s_t_e_m_/_e_t_c_/ contains the system and suid profile.

SSEEEE AALLSSOO
     awk(1), cat(1), ed(1), getopt(1), sed(1), sh(1), stty(1), dup(2),
     execve(2), getgid(2), getuid(2), mknod(2), mkfifo(2), open(2), pipe(2),
     rename(2), wait(2), getopt(3), nl_langinfo(3), setlocale(3), signal(3),
     system(3), tty(4), shells(5), environ(7), script(7), utf-8(7), mknod(8)

     _h_t_t_p_:_/_/_d_o_c_s_r_v_._s_c_o_._c_o_m_:_5_0_7_/_e_n_/_m_a_n_/_h_t_m_l_._C_/_s_h_._C_._h_t_m_l

     _h_t_t_p_s_:_/_/_w_w_w_._m_i_r_b_s_d_._o_r_g_/_k_s_h_-_c_h_a_n_._h_t_m

     Morris Bolsky, _T_h_e _K_o_r_n_S_h_e_l_l _C_o_m_m_a_n_d _a_n_d _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e, _P_r_e_n_t_i_c_e
     _H_a_l_l _P_T_R, xvi + 356 pages, 1989, ISBN 978-0-13-516972-8 (0-13-516972-0).

     Morris I. Bolsky and David G. Korn, _T_h_e _N_e_w _K_o_r_n_S_h_e_l_l _C_o_m_m_a_n_d _a_n_d
     _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e _(_2_n_d _E_d_i_t_i_o_n_), _P_r_e_n_t_i_c_e _H_a_l_l _P_T_R, xvi + 400 pages,
     1995, ISBN 978-0-13-182700-4 (0-13-182700-6).

     Stephen G. Kochan and Patrick H. Wood, _U_N_I_X _S_h_e_l_l _P_r_o_g_r_a_m_m_i_n_g, _S_a_m_s, 3rd
     Edition, xiii + 437 pages, 2003, ISBN 978-0-672-32490-1 (0-672-32490-3).

     IEEE Inc., _I_E_E_E _S_t_a_n_d_a_r_d _f_o_r _I_n_f_o_r_m_a_t_i_o_n _T_e_c_h_n_o_l_o_g_y _- _P_o_r_t_a_b_l_e _O_p_e_r_a_t_i_n_g
     _S_y_s_t_e_m _I_n_t_e_r_f_a_c_e _(_P_O_S_I_X_), _I_E_E_E _P_r_e_s_s, Part 2: Shell and Utilities,
     xvii + 1195 pages, 1993, ISBN 978-1-55937-255-8 (1-55937-255-9).

     Bill Rosenblatt, _L_e_a_r_n_i_n_g _t_h_e _K_o_r_n _S_h_e_l_l, _O_'_R_e_i_l_l_y, 360 pages, 1993, ISBN
     978-1-56592-054-5 (1-56592-054-6).

     Bill Rosenblatt and Arnold Robbins, _L_e_a_r_n_i_n_g _t_h_e _K_o_r_n _S_h_e_l_l_, _S_e_c_o_n_d
     _E_d_i_t_i_o_n, _O_'_R_e_i_l_l_y, 432 pages, 2002, ISBN 978-0-596-00195-7
     (0-596-00195-9).

     Barry Rosenberg, _K_o_r_n_S_h_e_l_l _P_r_o_g_r_a_m_m_i_n_g _T_u_t_o_r_i_a_l, _A_d_d_i_s_o_n_-_W_e_s_l_e_y
     _P_r_o_f_e_s_s_i_o_n_a_l, xxi + 324 pages, 1991, ISBN 978-0-201-56324-5
     (0-201-56324-X).

AAUUTTHHOORRSS
     TThhee MMiirrBBSSDD KKoorrnn SShheellll is developed by Thorsten Glaser <tg@mirbsd.org> and
     currently maintained as part of The MirOS Project.  This shell is based
     on the public domain 7th edition Bourne shell clone by Charles Forsyth,
     who kindly agreed to, in countries where the Public Domain status of the
     work may not be valid, grant a copyright licence to the general public to
     deal in the work without restriction and permission to sublicence
     derivates under the terms of any (OSI approved) Open Source licence, and
     parts of the BRL shell by Doug A. Gwyn, Doug Kingston, Ron Natalie,
     Arnold Robbins, Lou Salkind, and others.  The first release of ppddkksshh was
     created by Eric Gisin, and it was subsequently maintained by John R.
     MacMillan <_c_h_a_n_g_e_!_j_o_h_n_@_s_q_._s_q_._c_o_m>, Simon J. Gerraty <_s_j_g_@_z_e_n_._v_o_i_d_._o_z_._a_u>,
     and Michael Rendell <_m_i_c_h_a_e_l_@_c_s_._m_u_n_._c_a>.  The effort of several projects,
     such as Debian and OpenBSD, and other contributors including our users,
     to improve the shell is appreciated.  See the documentation, CVS, and web
     site for details.

     The BSD daemon is Copyright (C) Marshall Kirk McKusick.  The complete
     legalese is at: _h_t_t_p_s_:_/_/_w_w_w_._m_i_r_b_s_d_._o_r_g_/_T_a_C_-_m_k_s_h_._t_x_t

CCAAVVEEAATTSS
     mmkksshh has a different scope model from AT&T UNIX kksshh, which leads to sub-
     tile differences in semantics for identical builtins.  This can cause
     issues with a nnaammeerreeff to suddenly point to a local variable by accident;
     fixing this is hard.

     The parts of a pipeline, like below, are executed in subshells.  Thus,
     variable assignments inside them are not visible in the surrounding exe-
     cution environment.  Use co-processes instead.

           foo | bar | read baz            # will not change $baz
           foo | bar |& read -p baz        # will, however, do so

     mmkksshh provides a consistent set of 32-bit integer arithmetics, both signed
     and unsigned, with defined wraparound and sign of the result of a remain-
     der operation, even (defying POSIX) on 64-bit systems.  If you require
     64-bit integer arithmetics, use llkksshh (legacy mksh) instead, but be aware
     that, in POSIX, it's legal for the OS to make print $((2147483647 + 1))
     delete all files on your system, as it's Undefined Behaviour.

     mmkksshh provides a consistent, clear interface normally.  This may deviate
     from POSIX in optional or opinionated places, such as whether leading-
     digit-zero numbers should be interpreted as octal.  sseett --oo ppoossiixx will
     cause the shell (either mmkksshh or llkksshh) to behave more like the standard
     expects.

     For the purpose of POSIX, mmkksshh supports only the "C" locale.  mmkksshh's
     uuttff88--mmooddee only supports the Unicode BMP (Basic Multilingual Plane) and
     maps raw octets into the U+EF80..U+EFFF wide character range; compare
     _A_r_i_t_h_m_e_t_i_c _e_x_p_r_e_s_s_i_o_n_s.  The following POSIX sshh code toggles the
     uuttff88--mmooddee option dependent on the current POSIX locale for mksh to allow
     using the UTF-8 mode, within the constraints outlined above, in code por-
     table across various shell implementations:

           case ${KSH_VERSION:-} in
           *MIRBSD KSH*|*LEGACY KSH*)
                   case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
                   *[Uu][Tt][Ff]8*|*[Uu][Tt][Ff]-8*) set -U ;;
                   *) set +U ;;
                   esac ;;
           esac

BBUUGGSS
     Suspending (using ^Z) pipelines like the one below will only suspend the
     currently running part of the pipeline; in this example, "fubar" is imme-
     diately printed on suspension (but not later after an ffgg).

           $ /bin/sleep 666 && echo fubar

     The truncation process involved when changing HISTFILE does not free old
     history entries (leaks memory) and leaks old entries into the new history
     if their line numbers are not overwritten by same-numer entries from the
     persistent history file; truncating the on-disc file to HISTSIZE lines
     has always been broken and prone to history file corruption when multiple
     shells are accessing the file; the rollover process for the in-memory
     portion of the history is slow, should use memmove(3).

     This document attempts to describe mmkksshh RR5511 and up, compiled without any
     options impacting functionality, such as MKSH_SMALL, when not called as
     _/_b_i_n_/_s_h which, on some systems only, enables sseett --oo ppoossiixx or sseett --oo sshh
     automatically (whose behaviour differs across targets), for an operating
     environment supporting all of its advanced needs.

     Please report bugs in mmkksshh to the MirOS mailing list at
     <miros-mksh@mirbsd.org> or in the #!/bin/mksh (or #ksh) IRC channel at
     _i_r_c_._f_r_e_e_n_o_d_e_._n_e_t (Port 6697 SSL, 6667 unencrypted), or at:
     _h_t_t_p_s_:_/_/_l_a_u_n_c_h_p_a_d_._n_e_t_/_m_k_s_h

MirBSD                           July 10, 2015                          MirBSD
